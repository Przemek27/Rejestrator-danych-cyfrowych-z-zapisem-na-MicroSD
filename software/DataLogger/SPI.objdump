
SPI.elf:     file format elf32-littlenios2
SPI.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00002184

Program Header:
    LOAD off    0x00001000 vaddr 0x00002000 paddr 0x00002000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00002020 paddr 0x00002020 align 2**12
         filesz 0x00001594 memsz 0x00001594 flags r-x
    LOAD off    0x000025b4 vaddr 0x000035b4 paddr 0x0000362c align 2**12
         filesz 0x00000078 memsz 0x00000078 flags rw-
    LOAD off    0x000026a4 vaddr 0x000036a4 paddr 0x000036a4 align 2**12
         filesz 0x00000000 memsz 0x00000524 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00002000  00002000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000164  00002020  00002020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000011b4  00002184  00002184  00001184  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       0000027c  00003338  00003338  00002338  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000078  000035b4  0000362c  000025b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000524  000036a4  000036a4  000026a4  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  00003bc8  00003bc8  0000262c  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  0000262c  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000003e8  00000000  00000000  00002650  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000037af  00000000  00000000  00002a38  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001789  00000000  00000000  000061e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00001635  00000000  00000000  00007970  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  0000063c  00000000  00000000  00008fa8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001308  00000000  00000000  000095e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00001302  00000000  00000000  0000a8ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  0000bbf0  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000158  00000000  00000000  0000bc00  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0000d2c3  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  0000d2c6  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0000d2d2  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0000d2d3  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   00000006  00000000  00000000  0000d2d4  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    00000006  00000000  00000000  0000d2da  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   00000006  00000000  00000000  0000d2e0  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000009  00000000  00000000  0000d2e6  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 00000031  00000000  00000000  0000d2ef  2**0
                  CONTENTS, READONLY
 26 .jdi          00003cc9  00000000  00000000  0000d320  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     0004fe6a  00000000  00000000  00010fe9  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00002000 l    d  .entry	00000000 .entry
00002020 l    d  .exceptions	00000000 .exceptions
00002184 l    d  .text	00000000 .text
00003338 l    d  .rodata	00000000 .rodata
000035b4 l    d  .rwdata	00000000 .rwdata
000036a4 l    d  .bss	00000000 .bss
00003bc8 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../DataLogger_bsp//obj/HAL/src/crt0.o
000021bc l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 SDcard.c
00000000 l    df *ABS*	00000000 SPI.c
00000000 l    df *ABS*	00000000 dataLogger.c
00000000 l    df *ABS*	00000000 main.c
00002880 l     F .text	000000c0 timer_isr
000036bc l     O .bss	0000040c dataLogger
00002940 l     F .text	00000040 spi_isr
00000000 l    df *ABS*	00000000 uart.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00002bd8 l     F .text	0000006c udivmodsi4
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 alt_getchar.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
000032b0 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 int_errno.c
000036b4 g     O .bss	00000004 alt_instruction_exception_handler
00002f8c g     F .text	0000002c alt_main
00003ac8 g     O .bss	00000100 alt_irq
0000362c g       *ABS*	00000000 __flash_rwdata_start
000021c4 g     F .text	000000c8 sdCard_SendCommand
00002558 g     F .text	00000154 sdCard_SaveData
00003330 g     F .text	00000008 altera_nios2_gen2_irq_init
00000000  w      *UND*	00000000 __errno
00002000 g     F .entry	0000000c __reset
00002a9c g     F .text	0000013c uart_commandManage
00002020 g       *ABS*	00000000 __flash_exceptions_start
000036b8 g     O .bss	00000004 errno
000036ac g     O .bss	00000004 alt_argv
0000b60c g       *ABS*	00000000 _gp
000035b4 g     O .rwdata	00000030 alt_fd_list
00002d04 g     F .text	00000028 memcpy
00002834 g     F .text	0000002c dataLogger_manage
000032bc g     F .text	00000074 alt_exception_cause_generated_bad_addr
00002000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
00002cf4 g     F .text	00000008 .hidden __udivsi3
000026ac g     F .text	00000018 spi_SelectSlave
00003614 g     O .rwdata	00000004 alt_max_fd
00003bc8 g       *ABS*	00000000 __bss_end
00002e2c g     F .text	00000068 alt_iic_isr_register
00002d4c g     F .text	00000044 alt_getchar
00002e14 g     F .text	00000018 alt_ic_irq_enabled
000036a4 g     O .bss	00000004 alt_irq_active
000020fc g     F .exceptions	00000064 alt_irq_handler
000035e4 g     O .rwdata	00000028 alt_dev_null
000026e0 g     F .text	00000068 spi_SendByte
000032ac g     F .text	00000004 alt_dcache_flush_all
0000362c g       *ABS*	00000000 __ram_rwdata_end
00003618 g     O .rwdata	00000008 alt_dev_list
000035b4 g       *ABS*	00000000 __ram_rodata_end
00002cfc g     F .text	00000008 .hidden __umodsi3
00003bc8 g       *ABS*	00000000 end
0000321c g     F .text	00000090 altera_avalon_uart_write
00002160 g     F .exceptions	00000024 alt_instruction_exception_entry
00002438 g     F .text	00000120 sdCard_ReadData
00004000 g       *ABS*	00000000 __alt_stack_pointer
00002fb8 g     F .text	0000016c alt_printf
00002184 g     F .text	0000003c _start
0000318c g     F .text	00000004 alt_sys_init
000035b4 g       *ABS*	00000000 __ram_rwdata_start
00003338 g       *ABS*	00000000 __ram_rodata_start
00003bc8 g       *ABS*	00000000 __alt_stack_base
000026c4 g     F .text	0000001c spi_DeselectSlave
00002748 g     F .text	000000a4 spi_SendData
000027fc g     F .text	00000038 spi_ReadData
000036a4 g       *ABS*	00000000 __bss_start
00002d2c g     F .text	00000020 memset
00002980 g     F .text	0000011c main
000036a8 g     O .bss	00000004 alt_envp
00003610 g     O .rwdata	00000004 uart_0
00003628 g     O .rwdata	00000004 alt_errno
000027ec g     F .text	00000010 spi_IsData
0000228c g     F .text	000001ac sdCard_Init
00002c44 g     F .text	00000054 .hidden __divsi3
00003338 g       *ABS*	00000000 __flash_rodata_start
000021c0 g     F .text	00000004 delay
0000316c g     F .text	00000020 alt_irq_init
000036b0 g     O .bss	00000004 alt_argc
00002020 g       .exceptions	00000000 alt_irq_entry
00003620 g     O .rwdata	00000008 alt_fs_list
00002020 g       *ABS*	00000000 __ram_exceptions_start
00002860 g     F .text	00000020 dataLogger_init
00002d90 g     F .text	00000004 alt_ic_isr_register
0000362c g       *ABS*	00000000 _edata
00003bc8 g       *ABS*	00000000 _end
00002184 g       *ABS*	00000000 __ram_exceptions_end
00002dd4 g     F .text	00000040 alt_ic_irq_disable
00002c98 g     F .text	0000005c .hidden __modsi3
00004000 g       *ABS*	00000000 __alt_data_end
00002020 g     F .exceptions	00000000 alt_exception
0000200c g       .entry	00000000 _exit
00003124 g     F .text	00000048 alt_putchar
000032b8 g     F .text	00000004 alt_icache_flush_all
0000360c g     O .rwdata	00000004 alt_priority_mask
00002d94 g     F .text	00000040 alt_ic_irq_enable
00003190 g     F .text	0000008c altera_avalon_uart_read
00002e94 g     F .text	000000f8 alt_load



Disassembly of section .entry:

00002000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    2000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    2004:	08486114 	ori	at,at,8580
    jmp r1
    2008:	0800683a 	jmp	at

0000200c <_exit>:
	...

Disassembly of section .exceptions:

00002020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
    2020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
    2024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
    2028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
    202c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
    2030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
    2034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
    2038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
    203c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
    2040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
    2044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
    2048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
    204c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
    2050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
    2054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
    2058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
    205c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
    2060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
    2064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
    2068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
    206c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    2070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
    2074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
    2078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
    207c:	10000326 	beq	r2,zero,208c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
    2080:	20000226 	beq	r4,zero,208c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
    2084:	00020fc0 	call	20fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
    2088:	00000706 	br	20a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
    208c:	df401215 	stw	ea,72(sp)
        ldhu.n  r2, 0(r4)
        ldhu.n  r3, 2(r4)
        slli.n  r3, r3, 16
        or.n    r2, r2, r3 /* Instruction that caused exception */
#else
        ldw   r2, -4(ea)   /* Instruction that caused exception */
    2090:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
    2094:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
    2098:	00021600 	call	2160 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
    209c:	1000021e 	bne	r2,zero,20a8 <alt_exception+0x88>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
    20a0:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
    20a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
    20a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
    20ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
    20b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
    20b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
    20b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
    20bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
    20c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
    20c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
    20c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
    20cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
    20d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
    20d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
    20d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
    20dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
    20e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
    20e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
    20e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
    20ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
    20f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
    20f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
    20f8:	ef80083a 	eret

000020fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
    20fc:	defffe04 	addi	sp,sp,-8
    2100:	dfc00115 	stw	ra,4(sp)
    2104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
    2108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    210c:	04000034 	movhi	r16,0
    2110:	840eb204 	addi	r16,r16,15048

  active = alt_irq_pending ();

  do
  {
    i = 0;
    2114:	0005883a 	mov	r2,zero
    mask = 1;
    2118:	00c00044 	movi	r3,1
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
    211c:	190a703a 	and	r5,r3,r4
    2120:	28000c26 	beq	r5,zero,2154 <alt_irq_handler+0x58>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
    2124:	100490fa 	slli	r2,r2,3
    2128:	8087883a 	add	r3,r16,r2
    212c:	1805883a 	mov	r2,r3
    2130:	11000117 	ldw	r4,4(r2)
    2134:	18c00017 	ldw	r3,0(r3)
    2138:	183ee83a 	callr	r3
    213c:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
    2140:	203ff41e 	bne	r4,zero,2114 <_gp+0xffff6b08>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
    2144:	dfc00117 	ldw	ra,4(sp)
    2148:	dc000017 	ldw	r16,0(sp)
    214c:	dec00204 	addi	sp,sp,8
    2150:	f800283a 	ret
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
    2154:	18c7883a 	add	r3,r3,r3
      i++;
    2158:	10800044 	addi	r2,r2,1

    } while (1);
    215c:	003fef06 	br	211c <_gp+0xffff6b10>

00002160 <alt_instruction_exception_entry>:
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
    2160:	d0a02a17 	ldw	r2,-32600(gp)
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
    2164:	200b883a 	mov	r5,r4
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
    2168:	10000326 	beq	r2,zero,2178 <alt_instruction_exception_entry+0x18>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
    216c:	013fffc4 	movi	r4,-1
    2170:	000d883a 	mov	r6,zero
    2174:	1000683a 	jmp	r2
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
    2178:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
    217c:	0005883a 	mov	r2,zero
    2180:	f800283a 	ret

Disassembly of section .text:

00002184 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    2184:	06c00034 	movhi	sp,0
    ori sp, sp, %lo(__alt_stack_pointer)
    2188:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
    218c:	06800034 	movhi	gp,0
    ori gp, gp, %lo(_gp)
    2190:	d6ad8314 	ori	gp,gp,46604
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    2194:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    2198:	108da914 	ori	r2,r2,13988

    movhi r3, %hi(__bss_end)
    219c:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    21a0:	18cef214 	ori	r3,r3,15304

    beq r2, r3, 1f
    21a4:	10c00326 	beq	r2,r3,21b4 <_start+0x30>

0:
    stw zero, (r2)
    21a8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    21ac:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    21b0:	10fffd36 	bltu	r2,r3,21a8 <_gp+0xffff6b9c>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    21b4:	0002e940 	call	2e94 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    21b8:	0002f8c0 	call	2f8c <alt_main>

000021bc <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    21bc:	003fff06 	br	21bc <_gp+0xffff6bb0>

000021c0 <delay>:
	sdCard_SendCommand(cmd58, response, 5);

	return 1;
}

void delay(void){
    21c0:	f800283a 	ret

000021c4 <sdCard_SendCommand>:
	for(i=0;i<100000;i++){
		//do nothing
	}
}

void sdCard_SendCommand(alt_u8 *command,  alt_u32 *response, alt_u8 response_length){
    21c4:	defffb04 	addi	sp,sp,-20
    21c8:	dcc00315 	stw	r19,12(sp)
    21cc:	dc800215 	stw	r18,8(sp)
    21d0:	dc400115 	stw	r17,4(sp)
    21d4:	dc000015 	stw	r16,0(sp)
    21d8:	dfc00415 	stw	ra,16(sp)
    21dc:	2827883a 	mov	r19,r5
    21e0:	3023883a 	mov	r17,r6
    21e4:	2021883a 	mov	r16,r4
    21e8:	24800184 	addi	r18,r4,6
	alt_u8 i;

	/*Send command*/
	for(i=0;i<6;i++){
		spi_SendByte(SPI_0_BASE, 0, command[i]);
    21ec:	81800003 	ldbu	r6,0(r16)
    21f0:	01140004 	movi	r4,20480
    21f4:	000b883a 	mov	r5,zero
    21f8:	00026e00 	call	26e0 <spi_SendByte>
		/*Discard response*/
		if(spi_IsData(SPI_0_BASE)){
    21fc:	01140004 	movi	r4,20480
    2200:	00027ec0 	call	27ec <spi_IsData>
    2204:	10803fcc 	andi	r2,r2,255
    2208:	10000226 	beq	r2,zero,2214 <sdCard_SendCommand+0x50>
			spi_ReadData(SPI_0_BASE);
    220c:	01140004 	movi	r4,20480
    2210:	00027fc0 	call	27fc <spi_ReadData>
    2214:	84000044 	addi	r16,r16,1

void sdCard_SendCommand(alt_u8 *command,  alt_u32 *response, alt_u8 response_length){
	alt_u8 i;

	/*Send command*/
	for(i=0;i<6;i++){
    2218:	84bff41e 	bne	r16,r18,21ec <_gp+0xffff6be0>
    221c:	0025883a 	mov	r18,zero
		if(spi_IsData(SPI_0_BASE)){
			spi_ReadData(SPI_0_BASE);
		}
	}
	/*Read response*/
	for(i=0;i<(response_length+1);i++){
    2220:	8c403fcc 	andi	r17,r17,255
    2224:	94003fcc 	andi	r16,r18,255
    2228:	8c001116 	blt	r17,r16,2270 <sdCard_SendCommand+0xac>
		spi_SendByte(SPI_0_BASE, 0, 255);
    222c:	01140004 	movi	r4,20480
    2230:	000b883a 	mov	r5,zero
    2234:	01803fc4 	movi	r6,255
    2238:	00026e00 	call	26e0 <spi_SendByte>
		/*Read response*/
		if(spi_IsData(SPI_0_BASE)){
    223c:	01140004 	movi	r4,20480
    2240:	00027ec0 	call	27ec <spi_IsData>
    2244:	10803fcc 	andi	r2,r2,255
    2248:	10000726 	beq	r2,zero,2268 <sdCard_SendCommand+0xa4>
			alt_u32 temp;

			temp = spi_ReadData(SPI_0_BASE);
    224c:	01140004 	movi	r4,20480
    2250:	00027fc0 	call	27fc <spi_ReadData>
			if(i>0){							//Ignore first response
    2254:	80000426 	beq	r16,zero,2268 <sdCard_SendCommand+0xa4>
				response[i-1] = temp;
    2258:	8421883a 	add	r16,r16,r16
    225c:	8421883a 	add	r16,r16,r16
    2260:	9c21883a 	add	r16,r19,r16
    2264:	80bfff15 	stw	r2,-4(r16)
		if(spi_IsData(SPI_0_BASE)){
			spi_ReadData(SPI_0_BASE);
		}
	}
	/*Read response*/
	for(i=0;i<(response_length+1);i++){
    2268:	94800044 	addi	r18,r18,1
    226c:	003fed06 	br	2224 <_gp+0xffff6c18>
				response[i-1] = temp;
				//alt_printf("Response from microSD card: %x\n\r", response[i-1]);
			}
		}
	}
}
    2270:	dfc00417 	ldw	ra,16(sp)
    2274:	dcc00317 	ldw	r19,12(sp)
    2278:	dc800217 	ldw	r18,8(sp)
    227c:	dc400117 	ldw	r17,4(sp)
    2280:	dc000017 	ldw	r16,0(sp)
    2284:	dec00504 	addi	sp,sp,20
    2288:	f800283a 	ret

0000228c <sdCard_Init>:
#include "system.h"
#include "sys/alt_stdio.h"
#include "altera_avalon_spi.h"


alt_u8 sdCard_Init(void){
    228c:	deffef04 	addi	sp,sp,-68
	alt_u8 i;
	alt_u32 response[MAX_RESPONSE_LENGTH] = {0};
    2290:	d809883a 	mov	r4,sp
    2294:	000b883a 	mov	r5,zero
    2298:	01800504 	movi	r6,20
#include "system.h"
#include "sys/alt_stdio.h"
#include "altera_avalon_spi.h"


alt_u8 sdCard_Init(void){
    229c:	dfc01015 	stw	ra,64(sp)
    22a0:	dc400f15 	stw	r17,60(sp)
    22a4:	dc000e15 	stw	r16,56(sp)
	alt_u8 i;
	alt_u32 response[MAX_RESPONSE_LENGTH] = {0};
    22a8:	0002d2c0 	call	2d2c <memset>

	alt_u8 cmd0[6] = {64,0,0,0,0,149};			//start condition = 01 + cmd_nr(= 0); argument = 0,0,0,0; crc = 1001010 + stop condition = 1
    22ac:	01400034 	movhi	r5,0
    22b0:	d9000b04 	addi	r4,sp,44
    22b4:	294cce04 	addi	r5,r5,13112
    22b8:	01800184 	movi	r6,6
    22bc:	0002d040 	call	2d04 <memcpy>
	alt_u8 cmd8[6] = {72,0,0,1,170,135};
    22c0:	01400034 	movhi	r5,0
    22c4:	d9000984 	addi	r4,sp,38
    22c8:	294ccf84 	addi	r5,r5,13118
    22cc:	01800184 	movi	r6,6
    22d0:	0002d040 	call	2d04 <memcpy>
	alt_u8 cmd55[6] = {119,0,0,0,0,102};
    22d4:	01400034 	movhi	r5,0
    22d8:	d9000804 	addi	r4,sp,32
    22dc:	294cd104 	addi	r5,r5,13124
    22e0:	01800184 	movi	r6,6
    22e4:	0002d040 	call	2d04 <memcpy>
	alt_u8 cmd58[6] = {122,0,0,0,0,117};
    22e8:	01400034 	movhi	r5,0
    22ec:	d9000684 	addi	r4,sp,26
    22f0:	294cd284 	addi	r5,r5,13130
    22f4:	01800184 	movi	r6,6
    22f8:	0002d040 	call	2d04 <memcpy>
	alt_u8 acmd41[6] = {105,64,0,0,0,1};
    22fc:	01400034 	movhi	r5,0
    2300:	d9000504 	addi	r4,sp,20
    2304:	294cd404 	addi	r5,r5,13136
    2308:	01800184 	movi	r6,6
    230c:	0002d040 	call	2d04 <memcpy>

	alt_u32 cmd0_response = 1;
	alt_u8 cmd8_response[5] = {1,0,0,1,170};
    2310:	01400034 	movhi	r5,0
    2314:	d9000c84 	addi	r4,sp,50
    2318:	294cd584 	addi	r5,r5,13142
    231c:	01800144 	movi	r6,5
    2320:	0002d040 	call	2d04 <memcpy>
	alt_u8 cmd55_response = 1;
	alt_u8 acmd41_response = 0;

	/*Discard previous data*/
	if(spi_IsData(SPI_0_BASE)){
    2324:	01140004 	movi	r4,20480
    2328:	00027ec0 	call	27ec <spi_IsData>
    232c:	10803fcc 	andi	r2,r2,255
    2330:	10000226 	beq	r2,zero,233c <sdCard_Init+0xb0>
		spi_ReadData(SPI_0_BASE);
    2334:	01140004 	movi	r4,20480
    2338:	00027fc0 	call	27fc <spi_ReadData>
#include "system.h"
#include "sys/alt_stdio.h"
#include "altera_avalon_spi.h"


alt_u8 sdCard_Init(void){
    233c:	04000284 	movi	r16,10
		spi_ReadData(SPI_0_BASE);
	}

	/*1) Apply more than 74 cycles of Dummy-clock to the SD card.*/
	for(i=0;i<10;i++){
		spi_SendByte(SPI_0_BASE, 0, 255);
    2340:	01140004 	movi	r4,20480
    2344:	000b883a 	mov	r5,zero
    2348:	01803fc4 	movi	r6,255
    234c:	00026e00 	call	26e0 <spi_SendByte>
		/*Discard response*/
		if(spi_IsData(SPI_0_BASE)){
    2350:	01140004 	movi	r4,20480
    2354:	00027ec0 	call	27ec <spi_IsData>
    2358:	10803fcc 	andi	r2,r2,255
    235c:	10000226 	beq	r2,zero,2368 <sdCard_Init+0xdc>
			spi_ReadData(SPI_0_BASE);
    2360:	01140004 	movi	r4,20480
    2364:	00027fc0 	call	27fc <spi_ReadData>
    2368:	80bfffc4 	addi	r2,r16,-1
    236c:	1021883a 	mov	r16,r2
	if(spi_IsData(SPI_0_BASE)){
		spi_ReadData(SPI_0_BASE);
	}

	/*1) Apply more than 74 cycles of Dummy-clock to the SD card.*/
	for(i=0;i<10;i++){
    2370:	10803fcc 	andi	r2,r2,255
    2374:	103ff21e 	bne	r2,zero,2340 <_gp+0xffff6d34>
	 In case of SD mode operation, host should drive or detect 1 pin of SD Card I/F (Pull up register of 1 pin is pull
	up to “High” normally).
	 Card maintain selected operation mode except re-issue of CMD0 or power on below is SD mode initialization procedure.*/

	/*Send CMD0*/
	sdCard_SendCommand(cmd0, response, 1);
    2378:	04400044 	movi	r17,1
    237c:	d9000b04 	addi	r4,sp,44
    2380:	d80b883a 	mov	r5,sp
    2384:	880d883a 	mov	r6,r17
    2388:	00021c40 	call	21c4 <sdCard_SendCommand>
	/*Check response*/
	if(response[0] != cmd0_response){
    238c:	d8800017 	ldw	r2,0(sp)
    2390:	1440231e 	bne	r2,r17,2420 <sdCard_Init+0x194>
	}

	/*3) SEND_IF_COND (CMD8) is used to verify SD Memory Card interface operating condition*/

	/*Send CMD8*/
	sdCard_SendCommand(cmd8, response, 5);
    2394:	d9000984 	addi	r4,sp,38
    2398:	d80b883a 	mov	r5,sp
    239c:	01800144 	movi	r6,5
    23a0:	00021c40 	call	21c4 <sdCard_SendCommand>
    23a4:	0007883a 	mov	r3,zero
	/*Check response*/
	for(i=0;i<5;i++){
    23a8:	00800144 	movi	r2,5
    23ac:	18c9883a 	add	r4,r3,r3
    23b0:	2109883a 	add	r4,r4,r4
    23b4:	d9800c84 	addi	r6,sp,50
    23b8:	d909883a 	add	r4,sp,r4
    23bc:	30cb883a 	add	r5,r6,r3
		if(response[i] != cmd8_response[i]){
    23c0:	29400003 	ldbu	r5,0(r5)
    23c4:	21000017 	ldw	r4,0(r4)
    23c8:	2140151e 	bne	r4,r5,2420 <sdCard_Init+0x194>
    23cc:	18c00044 	addi	r3,r3,1
	/*3) SEND_IF_COND (CMD8) is used to verify SD Memory Card interface operating condition*/

	/*Send CMD8*/
	sdCard_SendCommand(cmd8, response, 5);
	/*Check response*/
	for(i=0;i<5;i++){
    23d0:	18bff61e 	bne	r3,r2,23ac <_gp+0xffff6da0>

	/*4) SD_SEND_OP_COND (ACMD41) is used to start initialization and to check if the card has completed initialization.*/

	do{									//Repeat until valid response
		/*CMD55 defines to the card that the next command is an application specific command rather than a standard command*/
		sdCard_SendCommand(cmd55, response, 1);
    23d4:	04400044 	movi	r17,1
    23d8:	d9000804 	addi	r4,sp,32
    23dc:	d80b883a 	mov	r5,sp
    23e0:	01800044 	movi	r6,1
    23e4:	00021c40 	call	21c4 <sdCard_SendCommand>
		/*Check response*/
		if(response[0] != cmd55_response){
    23e8:	d8800017 	ldw	r2,0(sp)
    23ec:	14400c1e 	bne	r2,r17,2420 <sdCard_Init+0x194>
			//Error
			return 0;
		}
		/*Send ACMD41*/
		sdCard_SendCommand(acmd41, response, 1);
    23f0:	d9000504 	addi	r4,sp,20
    23f4:	d80b883a 	mov	r5,sp
    23f8:	880d883a 	mov	r6,r17
    23fc:	00021c40 	call	21c4 <sdCard_SendCommand>
	} while(response[0] == 1);
    2400:	d8800017 	ldw	r2,0(sp)
    2404:	147ff426 	beq	r2,r17,23d8 <_gp+0xffff6dcc>

	/*Check response*/
	if(response[0] != acmd41_response){
    2408:	1000051e 	bne	r2,zero,2420 <sdCard_Init+0x194>
	/*5) After initialization is completed, the host should get CCS information in the response of CMD58. CCS is
	valid when the card accepted CMD8 and after the completion of initialization. CCS=0 means that the card
	is SDSD. CCS=1 means that the card is SDHC or SDXC.*/

	/*CMD58 reads OCR register*/
	sdCard_SendCommand(cmd58, response, 5);
    240c:	d9000684 	addi	r4,sp,26
    2410:	d80b883a 	mov	r5,sp
    2414:	01800144 	movi	r6,5
    2418:	00021c40 	call	21c4 <sdCard_SendCommand>

	return 1;
    241c:	8821883a 	mov	r16,r17
}
    2420:	8005883a 	mov	r2,r16
    2424:	dfc01017 	ldw	ra,64(sp)
    2428:	dc400f17 	ldw	r17,60(sp)
    242c:	dc000e17 	ldw	r16,56(sp)
    2430:	dec01104 	addi	sp,sp,68
    2434:	f800283a 	ret

00002438 <sdCard_ReadData>:
			}
		}
	}
}

void sdCard_ReadData(alt_u32 address, alt_u8 blocks, alt_u8 *buffer){		//FIXME: (utworzyc mozliwosc czytanie wielu blokow)
    2438:	defff404 	addi	sp,sp,-48
	alt_u8 cmd17_response = 0x00;
	alt_u16 i;
	alt_u32 response[MAX_RESPONSE_LENGTH];
	alt_u32 temp = 0;

	cmd17[0] = 81;
    243c:	00801444 	movi	r2,81
    2440:	d8800505 	stb	r2,20(sp)
	cmd17[1] = address >> 24;
    2444:	2004d63a 	srli	r2,r4,24
			}
		}
	}
}

void sdCard_ReadData(alt_u32 address, alt_u8 blocks, alt_u8 *buffer){		//FIXME: (utworzyc mozliwosc czytanie wielu blokow)
    2448:	dc800915 	stw	r18,36(sp)

	cmd17[0] = 81;
	cmd17[1] = address >> 24;
	cmd17[2] = address >> 16;
	cmd17[3] = address >> 8;
	cmd17[4] = address;
    244c:	d9000605 	stb	r4,24(sp)
	alt_u16 i;
	alt_u32 response[MAX_RESPONSE_LENGTH];
	alt_u32 temp = 0;

	cmd17[0] = 81;
	cmd17[1] = address >> 24;
    2450:	d8800545 	stb	r2,21(sp)
	cmd17[2] = address >> 16;
    2454:	2004d43a 	srli	r2,r4,16
			}
		}
	}
}

void sdCard_ReadData(alt_u32 address, alt_u8 blocks, alt_u8 *buffer){		//FIXME: (utworzyc mozliwosc czytanie wielu blokow)
    2458:	3025883a 	mov	r18,r6
	cmd17[3] = address >> 8;
	cmd17[4] = address;
	cmd17[5] = 1;

	//send CMD17 or CMD18 for multiple block read
	sdCard_SendCommand(cmd17, response, 1);
    245c:	d80b883a 	mov	r5,sp
	alt_u32 response[MAX_RESPONSE_LENGTH];
	alt_u32 temp = 0;

	cmd17[0] = 81;
	cmd17[1] = address >> 24;
	cmd17[2] = address >> 16;
    2460:	d8800585 	stb	r2,22(sp)
	cmd17[3] = address >> 8;
    2464:	2004d23a 	srli	r2,r4,8
	cmd17[4] = address;
	cmd17[5] = 1;

	//send CMD17 or CMD18 for multiple block read
	sdCard_SendCommand(cmd17, response, 1);
    2468:	01800044 	movi	r6,1
    246c:	d9000504 	addi	r4,sp,20
	alt_u32 temp = 0;

	cmd17[0] = 81;
	cmd17[1] = address >> 24;
	cmd17[2] = address >> 16;
	cmd17[3] = address >> 8;
    2470:	d88005c5 	stb	r2,23(sp)
	cmd17[4] = address;
	cmd17[5] = 1;
    2474:	00800044 	movi	r2,1
    2478:	d8800645 	stb	r2,25(sp)
			}
		}
	}
}

void sdCard_ReadData(alt_u32 address, alt_u8 blocks, alt_u8 *buffer){		//FIXME: (utworzyc mozliwosc czytanie wielu blokow)
    247c:	dfc00b15 	stw	ra,44(sp)
    2480:	dcc00a15 	stw	r19,40(sp)
    2484:	dc400815 	stw	r17,32(sp)
    2488:	dc000715 	stw	r16,28(sp)
	cmd17[3] = address >> 8;
	cmd17[4] = address;
	cmd17[5] = 1;

	//send CMD17 or CMD18 for multiple block read
	sdCard_SendCommand(cmd17, response, 1);
    248c:	00021c40 	call	21c4 <sdCard_SendCommand>
	if(response[0] != cmd17_response){
    2490:	d8800017 	ldw	r2,0(sp)
    2494:	10000426 	beq	r2,zero,24a8 <sdCard_ReadData+0x70>
		alt_printf("Error! Reading data from SD Card unsuccessful\n\r");
    2498:	01000034 	movhi	r4,0
    249c:	210cd704 	addi	r4,r4,13148
    24a0:	0002fb80 	call	2fb8 <alt_printf>
    24a4:	00002506 	br	253c <sdCard_ReadData+0x104>
    24a8:	0021883a 	mov	r16,zero
		return;
	}
	//alt_printf("Response: %x\n\r", response[0]);

	//wait for Data Token
	while(temp != 0xfe){
    24ac:	04403f84 	movi	r17,254
    24b0:	84400c26 	beq	r16,r17,24e4 <sdCard_ReadData+0xac>
		spi_SendByte(SPI_0_BASE, 0, 255);
    24b4:	01140004 	movi	r4,20480
    24b8:	000b883a 	mov	r5,zero
    24bc:	01803fc4 	movi	r6,255
    24c0:	00026e00 	call	26e0 <spi_SendByte>
		if(spi_IsData(SPI_0_BASE)){
    24c4:	01140004 	movi	r4,20480
    24c8:	00027ec0 	call	27ec <spi_IsData>
    24cc:	10803fcc 	andi	r2,r2,255
    24d0:	103ff726 	beq	r2,zero,24b0 <_gp+0xffff6ea4>
			//alt_printf("Response from microSD card: %x\n\r", temp);
			temp = spi_ReadData(SPI_0_BASE);
    24d4:	01140004 	movi	r4,20480
    24d8:	00027fc0 	call	27fc <spi_ReadData>
    24dc:	1021883a 	mov	r16,r2
    24e0:	003ff306 	br	24b0 <_gp+0xffff6ea4>
    24e4:	0021883a 	mov	r16,zero
	for(i=0;i<514;i++){								//512B data + 2B CRC
		spi_SendByte(SPI_0_BASE, 0, 255);
		/*Read data*/
		if(spi_IsData(SPI_0_BASE)){
			temp = spi_ReadData(SPI_0_BASE);
			if(i<512){								//Last two bytes - CRC
    24e8:	04c07fc4 	movi	r19,511
			temp = spi_ReadData(SPI_0_BASE);
		}
	}
	//alt_printf("Data Token received\n\r");

	for(i=0;i<514;i++){								//512B data + 2B CRC
    24ec:	04408084 	movi	r17,514
		spi_SendByte(SPI_0_BASE, 0, 255);
    24f0:	01140004 	movi	r4,20480
    24f4:	000b883a 	mov	r5,zero
    24f8:	01803fc4 	movi	r6,255
    24fc:	00026e00 	call	26e0 <spi_SendByte>
		/*Read data*/
		if(spi_IsData(SPI_0_BASE)){
    2500:	01140004 	movi	r4,20480
    2504:	00027ec0 	call	27ec <spi_IsData>
    2508:	10803fcc 	andi	r2,r2,255
    250c:	10000926 	beq	r2,zero,2534 <sdCard_ReadData+0xfc>
			temp = spi_ReadData(SPI_0_BASE);
    2510:	01140004 	movi	r4,20480
    2514:	00027fc0 	call	27fc <spi_ReadData>
			if(i<512){								//Last two bytes - CRC
    2518:	9c000236 	bltu	r19,r16,2524 <sdCard_ReadData+0xec>
    251c:	9407883a 	add	r3,r18,r16
				buffer[i] = temp;
    2520:	18800005 	stb	r2,0(r3)
			}
			alt_printf("Data from microSD card: %x\n\r", temp);
    2524:	01000034 	movhi	r4,0
    2528:	210ce304 	addi	r4,r4,13196
    252c:	100b883a 	mov	r5,r2
    2530:	0002fb80 	call	2fb8 <alt_printf>
    2534:	84000044 	addi	r16,r16,1
			temp = spi_ReadData(SPI_0_BASE);
		}
	}
	//alt_printf("Data Token received\n\r");

	for(i=0;i<514;i++){								//512B data + 2B CRC
    2538:	847fed1e 	bne	r16,r17,24f0 <_gp+0xffff6ee4>
			}
			alt_printf("Data from microSD card: %x\n\r", temp);
		}
	}

}
    253c:	dfc00b17 	ldw	ra,44(sp)
    2540:	dcc00a17 	ldw	r19,40(sp)
    2544:	dc800917 	ldw	r18,36(sp)
    2548:	dc400817 	ldw	r17,32(sp)
    254c:	dc000717 	ldw	r16,28(sp)
    2550:	dec00c04 	addi	sp,sp,48
    2554:	f800283a 	ret

00002558 <sdCard_SaveData>:

void sdCard_SaveData(alt_u32 address, alt_u8 *data){			//FIXME
    2558:	defffa04 	addi	sp,sp,-24
	alt_u8 cmd24[6] = {88, address >> 24, address >> 16, address >> 8, address, 1};		//FIXME: przyjete CRC = 0
    255c:	00801604 	movi	r2,88
    2560:	d8800005 	stb	r2,0(sp)
    2564:	2004d63a 	srli	r2,r4,24
		}
	}

}

void sdCard_SaveData(alt_u32 address, alt_u8 *data){			//FIXME
    2568:	dc000315 	stw	r16,12(sp)
	alt_u8 cmd24[6] = {88, address >> 24, address >> 16, address >> 8, address, 1};		//FIXME: przyjete CRC = 0
    256c:	d9000105 	stb	r4,4(sp)
    2570:	d8800045 	stb	r2,1(sp)
    2574:	2004d43a 	srli	r2,r4,16
		}
	}

}

void sdCard_SaveData(alt_u32 address, alt_u8 *data){			//FIXME
    2578:	2821883a 	mov	r16,r5
	alt_u8 cmd24[6] = {88, address >> 24, address >> 16, address >> 8, address, 1};		//FIXME: przyjete CRC = 0
	alt_u32 cmd24_response;
	alt_u32 i;
	alt_u32 temp;

	sdCard_SendCommand(cmd24, &cmd24_response, 1);
    257c:	01800044 	movi	r6,1
	}

}

void sdCard_SaveData(alt_u32 address, alt_u8 *data){			//FIXME
	alt_u8 cmd24[6] = {88, address >> 24, address >> 16, address >> 8, address, 1};		//FIXME: przyjete CRC = 0
    2580:	d8800085 	stb	r2,2(sp)
    2584:	2004d23a 	srli	r2,r4,8
	alt_u32 cmd24_response;
	alt_u32 i;
	alt_u32 temp;

	sdCard_SendCommand(cmd24, &cmd24_response, 1);
    2588:	d9400204 	addi	r5,sp,8
    258c:	d809883a 	mov	r4,sp
	}

}

void sdCard_SaveData(alt_u32 address, alt_u8 *data){			//FIXME
	alt_u8 cmd24[6] = {88, address >> 24, address >> 16, address >> 8, address, 1};		//FIXME: przyjete CRC = 0
    2590:	d88000c5 	stb	r2,3(sp)
    2594:	00800044 	movi	r2,1
    2598:	d8800145 	stb	r2,5(sp)
		}
	}

}

void sdCard_SaveData(alt_u32 address, alt_u8 *data){			//FIXME
    259c:	dfc00515 	stw	ra,20(sp)
    25a0:	dc400415 	stw	r17,16(sp)
	alt_u8 cmd24[6] = {88, address >> 24, address >> 16, address >> 8, address, 1};		//FIXME: przyjete CRC = 0
	alt_u32 cmd24_response;
	alt_u32 i;
	alt_u32 temp;

	sdCard_SendCommand(cmd24, &cmd24_response, 1);
    25a4:	00021c40 	call	21c4 <sdCard_SendCommand>

	if(cmd24_response != 0x00){
    25a8:	d8800217 	ldw	r2,8(sp)
    25ac:	10000426 	beq	r2,zero,25c0 <sdCard_SaveData+0x68>
		alt_printf("ERROR!\n\rSave'ing data to SD Card unsuccessful\n\r");
    25b0:	01000034 	movhi	r4,0
    25b4:	210ceb04 	addi	r4,r4,13228
    25b8:	0002fb80 	call	2fb8 <alt_printf>
    25bc:	00003606 	br	2698 <sdCard_SaveData+0x140>
    25c0:	04400204 	movi	r17,8
		return;
	}

	for(i=0;i<8;i++){							//8 clock ticks
		spi_SendByte(SPI_0_BASE, 0, 0xff);
    25c4:	01140004 	movi	r4,20480
    25c8:	000b883a 	mov	r5,zero
    25cc:	01803fc4 	movi	r6,255
    25d0:	8c7fffc4 	addi	r17,r17,-1
    25d4:	00026e00 	call	26e0 <spi_SendByte>
	if(cmd24_response != 0x00){
		alt_printf("ERROR!\n\rSave'ing data to SD Card unsuccessful\n\r");
		return;
	}

	for(i=0;i<8;i++){							//8 clock ticks
    25d8:	883ffa1e 	bne	r17,zero,25c4 <_gp+0xffff6fb8>
		spi_SendByte(SPI_0_BASE, 0, 0xff);
	}
	spi_SendByte(SPI_0_BASE, 0, 0xfe);			//send data start token
    25dc:	01140004 	movi	r4,20480
    25e0:	000b883a 	mov	r5,zero
    25e4:	01803f84 	movi	r6,254
    25e8:	00026e00 	call	26e0 <spi_SendByte>
    25ec:	84408004 	addi	r17,r16,512

	for(i=0;i<512;i++){							//send data
		spi_SendByte(SPI_0_BASE, 0, data[i]);
    25f0:	81800003 	ldbu	r6,0(r16)
    25f4:	01140004 	movi	r4,20480
    25f8:	000b883a 	mov	r5,zero
    25fc:	84000044 	addi	r16,r16,1
    2600:	00026e00 	call	26e0 <spi_SendByte>
	for(i=0;i<8;i++){							//8 clock ticks
		spi_SendByte(SPI_0_BASE, 0, 0xff);
	}
	spi_SendByte(SPI_0_BASE, 0, 0xfe);			//send data start token

	for(i=0;i<512;i++){							//send data
    2604:	847ffa1e 	bne	r16,r17,25f0 <_gp+0xffff6fe4>
		spi_SendByte(SPI_0_BASE, 0, data[i]);
	}

	spi_SendByte(SPI_0_BASE, 0, 0xff);			//send CRC (2B)
    2608:	01140004 	movi	r4,20480
    260c:	000b883a 	mov	r5,zero
    2610:	01803fc4 	movi	r6,255
    2614:	00026e00 	call	26e0 <spi_SendByte>
	spi_SendByte(SPI_0_BASE, 0, 0xff);
    2618:	01140004 	movi	r4,20480
    261c:	000b883a 	mov	r5,zero
    2620:	01803fc4 	movi	r6,255
    2624:	00026e00 	call	26e0 <spi_SendByte>
    2628:	04000404 	movi	r16,16

	for(i=0;i<16;i++){							//wait for response
		spi_SendByte(SPI_0_BASE, 0, 0xff);
    262c:	01140004 	movi	r4,20480
    2630:	000b883a 	mov	r5,zero
    2634:	01803fc4 	movi	r6,255
    2638:	00026e00 	call	26e0 <spi_SendByte>
		if(spi_IsData(SPI_0_BASE)){
    263c:	01140004 	movi	r4,20480
    2640:	00027ec0 	call	27ec <spi_IsData>
    2644:	10803fcc 	andi	r2,r2,255
    2648:	10000226 	beq	r2,zero,2654 <sdCard_SaveData+0xfc>
			temp = spi_ReadData(SPI_0_BASE);
    264c:	01140004 	movi	r4,20480
    2650:	00027fc0 	call	27fc <spi_ReadData>
    2654:	843fffc4 	addi	r16,r16,-1
	}

	spi_SendByte(SPI_0_BASE, 0, 0xff);			//send CRC (2B)
	spi_SendByte(SPI_0_BASE, 0, 0xff);

	for(i=0;i<16;i++){							//wait for response
    2658:	803ff41e 	bne	r16,zero,262c <_gp+0xffff7020>
	}

	temp = 0x00;

	while(temp == 0x00){						//wait for data save'ing process ends
		spi_SendByte(SPI_0_BASE, 0, 0xff);
    265c:	01140004 	movi	r4,20480
    2660:	000b883a 	mov	r5,zero
    2664:	01803fc4 	movi	r6,255
    2668:	00026e00 	call	26e0 <spi_SendByte>
		if(spi_IsData(SPI_0_BASE)){
    266c:	01140004 	movi	r4,20480
    2670:	00027ec0 	call	27ec <spi_IsData>
    2674:	10803fcc 	andi	r2,r2,255
    2678:	103ff826 	beq	r2,zero,265c <_gp+0xffff7050>
			temp = spi_ReadData(SPI_0_BASE);
    267c:	01140004 	movi	r4,20480
    2680:	00027fc0 	call	27fc <spi_ReadData>
		return;
	}

	temp = 0x00;

	while(temp == 0x00){						//wait for data save'ing process ends
    2684:	103ff526 	beq	r2,zero,265c <_gp+0xffff7050>
		spi_SendByte(SPI_0_BASE, 0, 0xff);
		if(spi_IsData(SPI_0_BASE)){
			temp = spi_ReadData(SPI_0_BASE);
		}
	}
	alt_printf("Response from SD Card after sector write: %x\n\r", temp);
    2688:	01000034 	movhi	r4,0
    268c:	210cf704 	addi	r4,r4,13276
    2690:	100b883a 	mov	r5,r2
    2694:	0002fb80 	call	2fb8 <alt_printf>

}
    2698:	dfc00517 	ldw	ra,20(sp)
    269c:	dc400417 	ldw	r17,16(sp)
    26a0:	dc000317 	ldw	r16,12(sp)
    26a4:	dec00604 	addi	sp,sp,24
    26a8:	f800283a 	ret

000026ac <spi_SelectSlave>:
#include "altera_avalon_spi_regs.h"
#include "altera_avalon_spi.h"
#include "sys/alt_stdio.h"

void spi_SelectSlave(alt_u32 base, alt_u32 slave){
	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    26ac:	00800044 	movi	r2,1
    26b0:	114a983a 	sll	r5,r2,r5
    26b4:	21400535 	stwio	r5,20(r4)
	// Set the SSO bit (force chipselect)
	IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
    26b8:	00810004 	movi	r2,1024
    26bc:	20800335 	stwio	r2,12(r4)
    26c0:	f800283a 	ret

000026c4 <spi_DeselectSlave>:
}

void spi_DeselectSlave(alt_u32 base, alt_u32 slave){
	alt_u32 control_reg;

	IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
    26c4:	00800044 	movi	r2,1
    26c8:	114a983a 	sll	r5,r2,r5
    26cc:	21400535 	stwio	r5,20(r4)
	// reset the SSO bit (force chipselect)
	control_reg = IORD_ALTERA_AVALON_SPI_CONTROL(base);
    26d0:	21000304 	addi	r4,r4,12
    26d4:	20800037 	ldwio	r2,0(r4)
	control_reg &= !ALTERA_AVALON_SPI_CONTROL_SSO_MSK;
	IOWR_ALTERA_AVALON_SPI_CONTROL(base, control_reg);
    26d8:	20000035 	stwio	zero,0(r4)
    26dc:	f800283a 	ret

000026e0 <spi_SendByte>:
}

void spi_SendByte(alt_u32 base, alt_u32 slave, alt_u8 data){
    26e0:	defffc04 	addi	sp,sp,-16
    26e4:	dc800215 	stw	r18,8(sp)
    26e8:	dc400115 	stw	r17,4(sp)
    26ec:	dc000015 	stw	r16,0(sp)
    26f0:	dfc00315 	stw	ra,12(sp)
    26f4:	2021883a 	mov	r16,r4
    26f8:	2825883a 	mov	r18,r5
    26fc:	3023883a 	mov	r17,r6
	alt_u32 status;

	spi_SelectSlave(base,slave);
    2700:	00026ac0 	call	26ac <spi_SelectSlave>

	do {
	status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    2704:	80c00204 	addi	r3,r16,8
    2708:	18800037 	ldwio	r2,0(r3)
	} while ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0);
    270c:	1080100c 	andi	r2,r2,64
    2710:	103ffd26 	beq	r2,zero,2708 <_gp+0xffff70fc>
	IOWR_ALTERA_AVALON_SPI_TXDATA(base,data);
    2714:	8c403fcc 	andi	r17,r17,255
    2718:	84400135 	stwio	r17,4(r16)

	/* Wait until the interface has finished transmitting */
	do
	{
		status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    271c:	18800037 	ldwio	r2,0(r3)
	}
	while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
    2720:	1080080c 	andi	r2,r2,32
    2724:	103ffd26 	beq	r2,zero,271c <_gp+0xffff7110>

	spi_DeselectSlave(base,slave);
    2728:	8009883a 	mov	r4,r16
    272c:	900b883a 	mov	r5,r18
}
    2730:	dfc00317 	ldw	ra,12(sp)
    2734:	dc800217 	ldw	r18,8(sp)
    2738:	dc400117 	ldw	r17,4(sp)
    273c:	dc000017 	ldw	r16,0(sp)
    2740:	dec00404 	addi	sp,sp,16
	{
		status = IORD_ALTERA_AVALON_SPI_STATUS(base);
	}
	while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);

	spi_DeselectSlave(base,slave);
    2744:	00026c41 	jmpi	26c4 <spi_DeselectSlave>

00002748 <spi_SendData>:
}

void spi_SendData(alt_u32 base, alt_u32 slave, const alt_u8 *data, alt_u8 length){		//FIXME: Funkcja po ka¿dm wys³anym bajcie "odznacza" slave'a
    2748:	defff904 	addi	sp,sp,-28
    274c:	39c03fcc 	andi	r7,r7,255
    2750:	dd400515 	stw	r21,20(sp)
    2754:	dd000415 	stw	r20,16(sp)
    2758:	dcc00315 	stw	r19,12(sp)
    275c:	dc800215 	stw	r18,8(sp)
    2760:	dc400115 	stw	r17,4(sp)
    2764:	dc000015 	stw	r16,0(sp)
    2768:	dfc00615 	stw	ra,24(sp)
    276c:	2023883a 	mov	r17,r4
    2770:	2827883a 	mov	r19,r5
    2774:	3021883a 	mov	r16,r6
    2778:	31e5883a 	add	r18,r6,r7

	for(i=0;i<length;i++){
		spi_SelectSlave(base,slave);

		/*Transmit a byte*/
		while(!(IORD_ALTERA_AVALON_SPI_STATUS(base) & ALTERA_AVALON_SPI_STATUS_TRDY_MSK));
    277c:	25000204 	addi	r20,r4,8
		IOWR_ALTERA_AVALON_SPI_TXDATA(base,*data++);
    2780:	25400104 	addi	r21,r4,4
//	alt_printf("Control register value: %x\n", reg);
//	reg = IORD_ALTERA_AVALON_SPI_SLAVE_SEL(base);
//	alt_printf("Slave Select register value: %x\n", reg);
//	spi_SelectSlave(base,slave);

	for(i=0;i<length;i++){
    2784:	84801026 	beq	r16,r18,27c8 <spi_SendData+0x80>
		spi_SelectSlave(base,slave);
    2788:	8809883a 	mov	r4,r17
    278c:	980b883a 	mov	r5,r19
    2790:	00026ac0 	call	26ac <spi_SelectSlave>

		/*Transmit a byte*/
		while(!(IORD_ALTERA_AVALON_SPI_STATUS(base) & ALTERA_AVALON_SPI_STATUS_TRDY_MSK));
    2794:	a0800037 	ldwio	r2,0(r20)
    2798:	1080100c 	andi	r2,r2,64
    279c:	103ffd26 	beq	r2,zero,2794 <_gp+0xffff7188>
		IOWR_ALTERA_AVALON_SPI_TXDATA(base,*data++);
    27a0:	80800003 	ldbu	r2,0(r16)
    27a4:	a8800035 	stwio	r2,0(r21)
//		/*Read and throw away received data*/
//		while(!(IORD_ALTERA_AVALON_SPI_STATUS(base) & ALTERA_AVALON_SPI_STATUS_RRDY_MSK));
//		IORD_ALTERA_AVALON_SPI_RXDATA(base);

		/* Wait until the interface has finished transmitting */
		while(!(IORD_ALTERA_AVALON_SPI_STATUS(base) & ALTERA_AVALON_SPI_STATUS_TMT_MSK));
    27a8:	a0800037 	ldwio	r2,0(r20)
    27ac:	1080080c 	andi	r2,r2,32
    27b0:	103ffd26 	beq	r2,zero,27a8 <_gp+0xffff719c>

		spi_DeselectSlave(base,slave);
    27b4:	8809883a 	mov	r4,r17
    27b8:	980b883a 	mov	r5,r19
    27bc:	00026c40 	call	26c4 <spi_DeselectSlave>
    27c0:	84000044 	addi	r16,r16,1
    27c4:	003fef06 	br	2784 <_gp+0xffff7178>
	}
//	/* Wait until the interface has finished transmitting */
//	while(!(IORD_ALTERA_AVALON_SPI_STATUS(base) & ALTERA_AVALON_SPI_STATUS_TMT_MSK));
//
//	spi_DeselectSlave(base,slave);
}
    27c8:	dfc00617 	ldw	ra,24(sp)
    27cc:	dd400517 	ldw	r21,20(sp)
    27d0:	dd000417 	ldw	r20,16(sp)
    27d4:	dcc00317 	ldw	r19,12(sp)
    27d8:	dc800217 	ldw	r18,8(sp)
    27dc:	dc400117 	ldw	r17,4(sp)
    27e0:	dc000017 	ldw	r16,0(sp)
    27e4:	dec00704 	addi	sp,sp,28
    27e8:	f800283a 	ret

000027ec <spi_IsData>:

bool spi_IsData(alt_u32 base){
	if(IORD_ALTERA_AVALON_SPI_STATUS(base) & ALTERA_AVALON_SPI_STATUS_RRDY_MSK){
    27ec:	20800237 	ldwio	r2,8(r4)
    27f0:	1004d1fa 	srli	r2,r2,7
		return true;
	}

	return false;
}
    27f4:	1080004c 	andi	r2,r2,1
    27f8:	f800283a 	ret

000027fc <spi_ReadData>:

alt_u32 spi_ReadData(alt_u32 base){
    27fc:	defffe04 	addi	sp,sp,-8
    2800:	dc000015 	stw	r16,0(sp)
    2804:	dfc00115 	stw	ra,4(sp)
    2808:	2021883a 	mov	r16,r4
	if(spi_IsData(base)){
    280c:	00027ec0 	call	27ec <spi_IsData>
    2810:	10803fcc 	andi	r2,r2,255
    2814:	10000226 	beq	r2,zero,2820 <spi_ReadData+0x24>
		alt_u32 data = IORD_ALTERA_AVALON_SPI_RXDATA(base);
    2818:	80800037 	ldwio	r2,0(r16)

		return data;
    281c:	00000106 	br	2824 <spi_ReadData+0x28>
	}

	return 1;
    2820:	00800044 	movi	r2,1
}
    2824:	dfc00117 	ldw	ra,4(sp)
    2828:	dc000017 	ldw	r16,0(sp)
    282c:	dec00204 	addi	sp,sp,8
    2830:	f800283a 	ret

00002834 <dataLogger_manage>:

#include "dataLogger.h"

void dataLogger_manage(DataLogger *logger){
	//TODO:
	if(logger->dataSaveToSD == 0xff){
    2834:	20c00083 	ldbu	r3,2(r4)
    2838:	00803fc4 	movi	r2,255
    283c:	1880011e 	bne	r3,r2,2844 <dataLogger_manage+0x10>
		//sdCard_SaveData(logger->buffer, address)
		logger->dataSaveToSD = 0x00;
    2840:	20000085 	stb	zero,2(r4)
	}
	if(logger->dataDump == 0xff){
    2844:	20c00043 	ldbu	r3,1(r4)
    2848:	1880011e 	bne	r3,r2,2850 <dataLogger_manage+0x1c>
		//Wyslij dane do PC
		logger->dataDump = 0x00;
    284c:	20000045 	stb	zero,1(r4)
	}
	if(logger->freqChange == 0xff){
    2850:	20c000c3 	ldbu	r3,3(r4)
    2854:	1880011e 	bne	r3,r2,285c <dataLogger_manage+0x28>
		//Zmien czestotliwosc probkowania
		logger->freqChange = 0x00;
    2858:	200000c5 	stb	zero,3(r4)
    285c:	f800283a 	ret

00002860 <dataLogger_init>:
	}
}

void dataLogger_init(DataLogger *logger){
	logger->bufIndex = 0;
	logger->activeBuffer = 1;
    2860:	00800044 	movi	r2,1
		logger->freqChange = 0x00;
	}
}

void dataLogger_init(DataLogger *logger){
	logger->bufIndex = 0;
    2864:	20010215 	stw	zero,1032(r4)
	logger->activeBuffer = 1;
    2868:	20810105 	stb	r2,1028(r4)
	logger->dataAcquire = 0;
    286c:	20000005 	stb	zero,0(r4)
	logger->dataDump = 0;
    2870:	20000045 	stb	zero,1(r4)
	logger->dataSaveToSD = 0;
    2874:	20000085 	stb	zero,2(r4)
	logger->freqChange = 0;
    2878:	200000c5 	stb	zero,3(r4)
    287c:	f800283a 	ret

00002880 <timer_isr>:
	//This resets the IRQ flag. Otherwise the IRQ will continuously run.
	IOWR_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE, 0x00);
}

//ISR for timer, runs every 1ms
static void timer_isr(void* isr_context){
    2880:	defffd04 	addi	sp,sp,-12
    2884:	dc000015 	stw	r16,0(sp)
	alt_u8 temp;

	if(dataLogger.dataAcquire == 0xff){
    2888:	04000034 	movhi	r16,0
    288c:	840daf04 	addi	r16,r16,14012
    2890:	80c00003 	ldbu	r3,0(r16)
	//This resets the IRQ flag. Otherwise the IRQ will continuously run.
	IOWR_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE, 0x00);
}

//ISR for timer, runs every 1ms
static void timer_isr(void* isr_context){
    2894:	dfc00215 	stw	ra,8(sp)
    2898:	dc400115 	stw	r17,4(sp)
	alt_u8 temp;

	if(dataLogger.dataAcquire == 0xff){
    289c:	00803fc4 	movi	r2,255
    28a0:	1880201e 	bne	r3,r2,2924 <timer_isr+0xa4>
		temp = IORD_ALTERA_AVALON_PIO_DATA(PIO_0_BASE);
    28a4:	00941804 	movi	r2,20576
    28a8:	10c00037 	ldwio	r3,0(r2)

		if(dataLogger.activeBuffer == 1){
    28ac:	01000044 	movi	r4,1
    28b0:	80810103 	ldbu	r2,1028(r16)
    28b4:	1100041e 	bne	r2,r4,28c8 <timer_isr+0x48>
			dataLogger.buffer1[dataLogger.bufIndex] = temp;
    28b8:	80810217 	ldw	r2,1032(r16)
    28bc:	8089883a 	add	r4,r16,r2
    28c0:	20c00105 	stb	r3,4(r4)
    28c4:	00000506 	br	28dc <timer_isr+0x5c>
			dataLogger.bufIndex++;
		}
		else if(dataLogger.activeBuffer == 2){
    28c8:	01000084 	movi	r4,2
    28cc:	1100061e 	bne	r2,r4,28e8 <timer_isr+0x68>
			dataLogger.buffer2[dataLogger.bufIndex] = temp;
    28d0:	80810217 	ldw	r2,1032(r16)
    28d4:	8089883a 	add	r4,r16,r2
    28d8:	20c08105 	stb	r3,516(r4)
			dataLogger.bufIndex++;
    28dc:	10800044 	addi	r2,r2,1
    28e0:	80810215 	stw	r2,1032(r16)
    28e4:	00000306 	br	28f4 <timer_isr+0x74>
		}
		else
			alt_printf("Error! Buffer not selected\n\r");
    28e8:	01000034 	movhi	r4,0
    28ec:	210d0304 	addi	r4,r4,13324
    28f0:	0002fb80 	call	2fb8 <alt_printf>

		if(dataLogger.bufIndex >= 512){				//after buffer is full allow save'ing data to SD card
    28f4:	80810217 	ldw	r2,1032(r16)
    28f8:	04400034 	movhi	r17,0
    28fc:	00c07fc4 	movi	r3,511
    2900:	8c4daf04 	addi	r17,r17,14012
    2904:	1880072e 	bgeu	r3,r2,2924 <timer_isr+0xa4>
			dataLogger.dataSaveToSD = 0xff;
			dataLogger.bufIndex = 0;
			dataLogger.activeBuffer = dataLogger.activeBuffer % 3;			//change active buffer
    2908:	89010103 	ldbu	r4,1028(r17)
		}
		else
			alt_printf("Error! Buffer not selected\n\r");

		if(dataLogger.bufIndex >= 512){				//after buffer is full allow save'ing data to SD card
			dataLogger.dataSaveToSD = 0xff;
    290c:	00bfffc4 	movi	r2,-1
			dataLogger.bufIndex = 0;
			dataLogger.activeBuffer = dataLogger.activeBuffer % 3;			//change active buffer
    2910:	014000c4 	movi	r5,3
		}
		else
			alt_printf("Error! Buffer not selected\n\r");

		if(dataLogger.bufIndex >= 512){				//after buffer is full allow save'ing data to SD card
			dataLogger.dataSaveToSD = 0xff;
    2914:	88800085 	stb	r2,2(r17)
			dataLogger.bufIndex = 0;
    2918:	88010215 	stw	zero,1032(r17)
			dataLogger.activeBuffer = dataLogger.activeBuffer % 3;			//change active buffer
    291c:	0002cfc0 	call	2cfc <__umodsi3>
    2920:	88810105 	stb	r2,1028(r17)
		}
	}
	IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0);
    2924:	00941004 	movi	r2,20544
    2928:	10000035 	stwio	zero,0(r2)
}
    292c:	dfc00217 	ldw	ra,8(sp)
    2930:	dc400117 	ldw	r17,4(sp)
    2934:	dc000017 	ldw	r16,0(sp)
    2938:	dec00304 	addi	sp,sp,12
    293c:	f800283a 	ret

00002940 <spi_isr>:
#include "dataLogger.h"

static DataLogger dataLogger;

//This is the ISR that runs when the SPI error occurred
static void spi_isr(void* isr_context){
    2940:	defffe04 	addi	sp,sp,-8
    2944:	dc000015 	stw	r16,0(sp)
//	if(IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) & ALTERA_AVALON_SPI_STATUS_RRDY_MSK){
//		alt_printf("ISR :) %x \n" ,  IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE));
//	}
	if(IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) & ALTERA_AVALON_SPI_STATUS_E_MSK){
    2948:	04140204 	movi	r16,20488
#include "dataLogger.h"

static DataLogger dataLogger;

//This is the ISR that runs when the SPI error occurred
static void spi_isr(void* isr_context){
    294c:	dfc00115 	stw	ra,4(sp)
//	if(IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) & ALTERA_AVALON_SPI_STATUS_RRDY_MSK){
//		alt_printf("ISR :) %x \n" ,  IORD_ALTERA_AVALON_SPI_RXDATA(SPI_0_BASE));
//	}
	if(IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE) & ALTERA_AVALON_SPI_STATUS_E_MSK){
    2950:	80800037 	ldwio	r2,0(r16)
    2954:	1080400c 	andi	r2,r2,256
    2958:	10000426 	beq	r2,zero,296c <spi_isr+0x2c>
		alt_printf("SPI Error occurred !!!\n\rStatus register value: %x\n\r", IORD_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE));
    295c:	81400037 	ldwio	r5,0(r16)
    2960:	01000034 	movhi	r4,0
    2964:	210d0b04 	addi	r4,r4,13356
    2968:	0002fb80 	call	2fb8 <alt_printf>
	}
	//This resets the IRQ flag. Otherwise the IRQ will continuously run.
	IOWR_ALTERA_AVALON_SPI_STATUS(SPI_0_BASE, 0x00);
    296c:	80000035 	stwio	zero,0(r16)
}
    2970:	dfc00117 	ldw	ra,4(sp)
    2974:	dc000017 	ldw	r16,0(sp)
    2978:	dec00204 	addi	sp,sp,8
    297c:	f800283a 	ret

00002980 <main>:
int main()
{
  int ret;
  alt_u32 i;

  alt_printf("Hello from Nios II!\n\r");
    2980:	01000034 	movhi	r4,0
	}
	IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0);
}

int main()
{
    2984:	deff7e04 	addi	sp,sp,-520
  int ret;
  alt_u32 i;

  alt_printf("Hello from Nios II!\n\r");
    2988:	210d1804 	addi	r4,r4,13408
	}
	IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_0_BASE, 0);
}

int main()
{
    298c:	dfc08115 	stw	ra,516(sp)
  int ret;
  alt_u32 i;

  alt_printf("Hello from Nios II!\n\r");
    2990:	0002fb80 	call	2fb8 <alt_printf>
  alt_u8 buffer[512];

  dataLogger_init(&dataLogger);
    2994:	01000034 	movhi	r4,0
    2998:	210daf04 	addi	r4,r4,14012
    299c:	00028600 	call	2860 <dataLogger_init>

  //This registers the Slave IRQ with NIOS
  ret = alt_ic_isr_register(SPI_0_IRQ_INTERRUPT_CONTROLLER_ID, SPI_0_IRQ, spi_isr, (void *)sdCard_Init, 0x0);
    29a0:	01800034 	movhi	r6,0
    29a4:	01c00034 	movhi	r7,0
    29a8:	318a5004 	addi	r6,r6,10560
    29ac:	39c8a304 	addi	r7,r7,8844
    29b0:	d8000015 	stw	zero,0(sp)
    29b4:	0009883a 	mov	r4,zero
    29b8:	01400044 	movi	r5,1
    29bc:	0002d900 	call	2d90 <alt_ic_isr_register>
  alt_printf("IRQ register return %x \n\r", ret);
    29c0:	01000034 	movhi	r4,0
    29c4:	100b883a 	mov	r5,r2
    29c8:	210d1e04 	addi	r4,r4,13432
    29cc:	0002fb80 	call	2fb8 <alt_printf>

  //You need to enable the IRQ in the IP core control register as well.
  IOWR_ALTERA_AVALON_SPI_CONTROL(SPI_0_BASE, ALTERA_AVALON_SPI_CONTROL_IE_MSK);
    29d0:	00940304 	movi	r2,20492
    29d4:	00c04004 	movi	r3,256
    29d8:	10c00035 	stwio	r3,0(r2)

  //register the timer irq to be serviced by timer_isr() function
  ret = alt_ic_isr_register(TIMER_0_IRQ_INTERRUPT_CONTROLLER_ID, TIMER_0_IRQ, timer_isr, NULL, 0x0);
    29dc:	01800034 	movhi	r6,0
    29e0:	318a2004 	addi	r6,r6,10368
    29e4:	000f883a 	mov	r7,zero
    29e8:	d8000015 	stw	zero,0(sp)
    29ec:	0009883a 	mov	r4,zero
    29f0:	01400084 	movi	r5,2
    29f4:	0002d900 	call	2d90 <alt_ic_isr_register>
  alt_printf("IRQ register return %x \n\r", ret);
    29f8:	01000034 	movhi	r4,0
    29fc:	100b883a 	mov	r5,r2
    2a00:	210d1e04 	addi	r4,r4,13432
    2a04:	0002fb80 	call	2fb8 <alt_printf>

  //activate the timer
  IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_0_BASE,
    2a08:	00941104 	movi	r2,20548
    2a0c:	00c001c4 	movi	r3,7
    2a10:	10c00035 	stwio	r3,0(r2)
                  ALTERA_AVALON_TIMER_CONTROL_CONT_MSK
                | ALTERA_AVALON_TIMER_CONTROL_START_MSK
                | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK);

  if(sdCard_Init()){
    2a14:	000228c0 	call	228c <sdCard_Init>
    2a18:	10803fcc 	andi	r2,r2,255
    2a1c:	10000826 	beq	r2,zero,2a40 <main+0xc0>
	 alt_printf("SD Card Initialization successful\n\r");
    2a20:	01000034 	movhi	r4,0
    2a24:	210d2504 	addi	r4,r4,13460
    2a28:	0002fb80 	call	2fb8 <alt_printf>
    2a2c:	01400034 	movhi	r5,0
  /*---------------TEST---------------------*/
  /*Read Data*/
  //sdCard_ReadData(1,1, buffer);
  /*Save Data*/

  for(i=0;i<512;i++){
    2a30:	0005883a 	mov	r2,zero
    2a34:	294daf04 	addi	r5,r5,14012
    2a38:	00c08004 	movi	r3,512
    2a3c:	00000406 	br	2a50 <main+0xd0>

  if(sdCard_Init()){
	 alt_printf("SD Card Initialization successful\n\r");
  }
  else{
	  alt_printf("SD Card Initialization failed\n\r");
    2a40:	01000034 	movhi	r4,0
    2a44:	210d2e04 	addi	r4,r4,13496
    2a48:	0002fb80 	call	2fb8 <alt_printf>
	  while(1);
    2a4c:	003fff06 	br	2a4c <_gp+0xffff7440>
    2a50:	1149883a 	add	r4,r2,r5
  /*Read Data*/
  //sdCard_ReadData(1,1, buffer);
  /*Save Data*/

  for(i=0;i<512;i++){
	  dataLogger.buffer1[i] = i%256;
    2a54:	20800105 	stb	r2,4(r4)
  /*---------------TEST---------------------*/
  /*Read Data*/
  //sdCard_ReadData(1,1, buffer);
  /*Save Data*/

  for(i=0;i<512;i++){
    2a58:	10800044 	addi	r2,r2,1
    2a5c:	10fffc1e 	bne	r2,r3,2a50 <_gp+0xffff7444>
	  dataLogger.buffer1[i] = i%256;
  }
  sdCard_SaveData(2048,dataLogger.buffer1);
    2a60:	01400034 	movhi	r5,0
    2a64:	01020004 	movi	r4,2048
    2a68:	294db004 	addi	r5,r5,14016
    2a6c:	00025580 	call	2558 <sdCard_SaveData>
  sdCard_ReadData(2048,1, buffer);
    2a70:	01020004 	movi	r4,2048
    2a74:	01400044 	movi	r5,1
    2a78:	d9800104 	addi	r6,sp,4
    2a7c:	00024380 	call	2438 <sdCard_ReadData>
  /*----------------------------------------*/

  while(1){
	  uart_commandManage(&dataLogger);
    2a80:	01000034 	movhi	r4,0
    2a84:	210daf04 	addi	r4,r4,14012
    2a88:	0002a9c0 	call	2a9c <uart_commandManage>
	  dataLogger_manage(&dataLogger);
    2a8c:	01000034 	movhi	r4,0
    2a90:	210daf04 	addi	r4,r4,14012
    2a94:	00028340 	call	2834 <dataLogger_manage>
  }
    2a98:	003ff906 	br	2a80 <_gp+0xffff7474>

00002a9c <uart_commandManage>:

#include "uart.h"
#include "altera_avalon_uart_regs.h"
#include "sys/alt_stdio.h"

void uart_commandManage(DataLogger *logger){
    2a9c:	defffe04 	addi	sp,sp,-8
    2aa0:	dc000015 	stw	r16,0(sp)
    2aa4:	dfc00115 	stw	ra,4(sp)
    2aa8:	2021883a 	mov	r16,r4
	char c;

	c = alt_getchar();			//FIXME: funkcja czeka na uzytkownika
    2aac:	0002d4c0 	call	2d4c <alt_getchar>

	switch(c){
    2ab0:	10803fcc 	andi	r2,r2,255
    2ab4:	1080201c 	xori	r2,r2,128
    2ab8:	10bfe004 	addi	r2,r2,-128
    2abc:	00c014c4 	movi	r3,83
    2ac0:	10c02426 	beq	r2,r3,2b54 <uart_commandManage+0xb8>
    2ac4:	18801916 	blt	r3,r2,2b2c <uart_commandManage+0x90>
    2ac8:	00c01104 	movi	r3,68
    2acc:	10c02c26 	beq	r2,r3,2b80 <uart_commandManage+0xe4>
    2ad0:	18801116 	blt	r3,r2,2b18 <uart_commandManage+0x7c>
    2ad4:	00c00fc4 	movi	r3,63
    2ad8:	10c0351e 	bne	r2,r3,2bb0 <uart_commandManage+0x114>
			alt_printf("freq\n\r");
			logger->freqChange = 0xff;
			break;

		case '?':
			alt_printf("Commands:\n\r");
    2adc:	01000034 	movhi	r4,0
    2ae0:	210d3e04 	addi	r4,r4,13560
    2ae4:	0002fb80 	call	2fb8 <alt_printf>
			alt_printf("'s' - Start data acquisition\n\r");
    2ae8:	01000034 	movhi	r4,0
    2aec:	210d4104 	addi	r4,r4,13572
    2af0:	0002fb80 	call	2fb8 <alt_printf>
			alt_printf("'p' - Stop data acquisition\n\r");
    2af4:	01000034 	movhi	r4,0
    2af8:	210d4904 	addi	r4,r4,13604
    2afc:	0002fb80 	call	2fb8 <alt_printf>
			alt_printf("'d' - Read data\n\r");
    2b00:	01000034 	movhi	r4,0
    2b04:	210d5104 	addi	r4,r4,13636
    2b08:	0002fb80 	call	2fb8 <alt_printf>
			alt_printf("'f' - Change sample rate\n\r");
    2b0c:	01000034 	movhi	r4,0
    2b10:	210d5604 	addi	r4,r4,13656
    2b14:	00002806 	br	2bb8 <uart_commandManage+0x11c>
void uart_commandManage(DataLogger *logger){
	char c;

	c = alt_getchar();			//FIXME: funkcja czeka na uzytkownika

	switch(c){
    2b18:	00c01184 	movi	r3,70
    2b1c:	10c01e26 	beq	r2,r3,2b98 <uart_commandManage+0xfc>
    2b20:	00c01404 	movi	r3,80
    2b24:	10c01126 	beq	r2,r3,2b6c <uart_commandManage+0xd0>
    2b28:	00002106 	br	2bb0 <uart_commandManage+0x114>
    2b2c:	00c01984 	movi	r3,102
    2b30:	10c01926 	beq	r2,r3,2b98 <uart_commandManage+0xfc>
    2b34:	18800316 	blt	r3,r2,2b44 <uart_commandManage+0xa8>
    2b38:	00c01904 	movi	r3,100
    2b3c:	10c01026 	beq	r2,r3,2b80 <uart_commandManage+0xe4>
    2b40:	00001b06 	br	2bb0 <uart_commandManage+0x114>
    2b44:	00c01c04 	movi	r3,112
    2b48:	10c00826 	beq	r2,r3,2b6c <uart_commandManage+0xd0>
    2b4c:	00c01cc4 	movi	r3,115
    2b50:	10c0171e 	bne	r2,r3,2bb0 <uart_commandManage+0x114>
		case 's': case 'S':
			alt_printf("start\n\r");
    2b54:	01000034 	movhi	r4,0
    2b58:	210d3604 	addi	r4,r4,13528
    2b5c:	0002fb80 	call	2fb8 <alt_printf>
			logger->dataAcquire = 0xff;
    2b60:	00bfffc4 	movi	r2,-1
    2b64:	80800005 	stb	r2,0(r16)
			break;
    2b68:	00001706 	br	2bc8 <uart_commandManage+0x12c>

		case 'p': case 'P':
			alt_printf("stop\n\r");
    2b6c:	01000034 	movhi	r4,0
    2b70:	210d3804 	addi	r4,r4,13536
    2b74:	0002fb80 	call	2fb8 <alt_printf>
			logger->dataAcquire = 0x00;
    2b78:	80000005 	stb	zero,0(r16)
			break;
    2b7c:	00001206 	br	2bc8 <uart_commandManage+0x12c>

		case 'd': case 'D':				//FIXME: komenda powinna byc aktywna jedynie po udanej akwizycji danych
			alt_printf("dump\n\r");
    2b80:	01000034 	movhi	r4,0
    2b84:	210d3a04 	addi	r4,r4,13544
    2b88:	0002fb80 	call	2fb8 <alt_printf>
			logger->dataDump = 0xff;
    2b8c:	00bfffc4 	movi	r2,-1
    2b90:	80800045 	stb	r2,1(r16)
			break;
    2b94:	00000c06 	br	2bc8 <uart_commandManage+0x12c>

		case 'f': case 'F':
			alt_printf("freq\n\r");
    2b98:	01000034 	movhi	r4,0
    2b9c:	210d3c04 	addi	r4,r4,13552
    2ba0:	0002fb80 	call	2fb8 <alt_printf>
			logger->freqChange = 0xff;
    2ba4:	00bfffc4 	movi	r2,-1
    2ba8:	808000c5 	stb	r2,3(r16)
			break;
    2bac:	00000606 	br	2bc8 <uart_commandManage+0x12c>
			alt_printf("'d' - Read data\n\r");
			alt_printf("'f' - Change sample rate\n\r");
			break;

		default:
			alt_printf("Unknown command\n\rTo see all commands press '?'\n\r");
    2bb0:	01000034 	movhi	r4,0
    2bb4:	210d5d04 	addi	r4,r4,13684
			break;
	}

}
    2bb8:	dfc00117 	ldw	ra,4(sp)
    2bbc:	dc000017 	ldw	r16,0(sp)
    2bc0:	dec00204 	addi	sp,sp,8
			alt_printf("'d' - Read data\n\r");
			alt_printf("'f' - Change sample rate\n\r");
			break;

		default:
			alt_printf("Unknown command\n\rTo see all commands press '?'\n\r");
    2bc4:	0002fb81 	jmpi	2fb8 <alt_printf>
			break;
	}

}
    2bc8:	dfc00117 	ldw	ra,4(sp)
    2bcc:	dc000017 	ldw	r16,0(sp)
    2bd0:	dec00204 	addi	sp,sp,8
    2bd4:	f800283a 	ret

00002bd8 <udivmodsi4>:
    2bd8:	2900182e 	bgeu	r5,r4,2c3c <udivmodsi4+0x64>
    2bdc:	28001716 	blt	r5,zero,2c3c <udivmodsi4+0x64>
    2be0:	00800804 	movi	r2,32
    2be4:	00c00044 	movi	r3,1
    2be8:	00000206 	br	2bf4 <udivmodsi4+0x1c>
    2bec:	10001126 	beq	r2,zero,2c34 <udivmodsi4+0x5c>
    2bf0:	28000516 	blt	r5,zero,2c08 <udivmodsi4+0x30>
    2bf4:	294b883a 	add	r5,r5,r5
    2bf8:	10bfffc4 	addi	r2,r2,-1
    2bfc:	18c7883a 	add	r3,r3,r3
    2c00:	293ffa36 	bltu	r5,r4,2bec <_gp+0xffff75e0>
    2c04:	18000b26 	beq	r3,zero,2c34 <udivmodsi4+0x5c>
    2c08:	0005883a 	mov	r2,zero
    2c0c:	21400236 	bltu	r4,r5,2c18 <udivmodsi4+0x40>
    2c10:	2149c83a 	sub	r4,r4,r5
    2c14:	10c4b03a 	or	r2,r2,r3
    2c18:	1806d07a 	srli	r3,r3,1
    2c1c:	280ad07a 	srli	r5,r5,1
    2c20:	183ffa1e 	bne	r3,zero,2c0c <_gp+0xffff7600>
    2c24:	3000011e 	bne	r6,zero,2c2c <udivmodsi4+0x54>
    2c28:	f800283a 	ret
    2c2c:	2005883a 	mov	r2,r4
    2c30:	f800283a 	ret
    2c34:	0005883a 	mov	r2,zero
    2c38:	003ffa06 	br	2c24 <_gp+0xffff7618>
    2c3c:	00c00044 	movi	r3,1
    2c40:	003ff106 	br	2c08 <_gp+0xffff75fc>

00002c44 <__divsi3>:
    2c44:	defffe04 	addi	sp,sp,-8
    2c48:	dfc00115 	stw	ra,4(sp)
    2c4c:	dc000015 	stw	r16,0(sp)
    2c50:	20000b16 	blt	r4,zero,2c80 <__divsi3+0x3c>
    2c54:	0021883a 	mov	r16,zero
    2c58:	28000c16 	blt	r5,zero,2c8c <__divsi3+0x48>
    2c5c:	000d883a 	mov	r6,zero
    2c60:	0002bd80 	call	2bd8 <udivmodsi4>
    2c64:	0407c83a 	sub	r3,zero,r16
    2c68:	1884f03a 	xor	r2,r3,r2
    2c6c:	1405883a 	add	r2,r2,r16
    2c70:	dfc00117 	ldw	ra,4(sp)
    2c74:	dc000017 	ldw	r16,0(sp)
    2c78:	dec00204 	addi	sp,sp,8
    2c7c:	f800283a 	ret
    2c80:	0109c83a 	sub	r4,zero,r4
    2c84:	04000044 	movi	r16,1
    2c88:	283ff40e 	bge	r5,zero,2c5c <_gp+0xffff7650>
    2c8c:	014bc83a 	sub	r5,zero,r5
    2c90:	8400005c 	xori	r16,r16,1
    2c94:	003ff106 	br	2c5c <_gp+0xffff7650>

00002c98 <__modsi3>:
    2c98:	defffd04 	addi	sp,sp,-12
    2c9c:	dfc00215 	stw	ra,8(sp)
    2ca0:	dc400115 	stw	r17,4(sp)
    2ca4:	dc000015 	stw	r16,0(sp)
    2ca8:	20000c16 	blt	r4,zero,2cdc <__modsi3+0x44>
    2cac:	0023883a 	mov	r17,zero
    2cb0:	0021883a 	mov	r16,zero
    2cb4:	28000d16 	blt	r5,zero,2cec <__modsi3+0x54>
    2cb8:	01800044 	movi	r6,1
    2cbc:	0002bd80 	call	2bd8 <udivmodsi4>
    2cc0:	1404f03a 	xor	r2,r2,r16
    2cc4:	8885883a 	add	r2,r17,r2
    2cc8:	dfc00217 	ldw	ra,8(sp)
    2ccc:	dc400117 	ldw	r17,4(sp)
    2cd0:	dc000017 	ldw	r16,0(sp)
    2cd4:	dec00304 	addi	sp,sp,12
    2cd8:	f800283a 	ret
    2cdc:	0109c83a 	sub	r4,zero,r4
    2ce0:	04400044 	movi	r17,1
    2ce4:	043fffc4 	movi	r16,-1
    2ce8:	283ff30e 	bge	r5,zero,2cb8 <_gp+0xffff76ac>
    2cec:	014bc83a 	sub	r5,zero,r5
    2cf0:	003ff106 	br	2cb8 <_gp+0xffff76ac>

00002cf4 <__udivsi3>:
    2cf4:	000d883a 	mov	r6,zero
    2cf8:	0002bd81 	jmpi	2bd8 <udivmodsi4>

00002cfc <__umodsi3>:
    2cfc:	01800044 	movi	r6,1
    2d00:	0002bd81 	jmpi	2bd8 <udivmodsi4>

00002d04 <memcpy>:
    2d04:	2005883a 	mov	r2,r4
    2d08:	0007883a 	mov	r3,zero
    2d0c:	19800626 	beq	r3,r6,2d28 <memcpy+0x24>
    2d10:	28c9883a 	add	r4,r5,r3
    2d14:	21c00003 	ldbu	r7,0(r4)
    2d18:	10c9883a 	add	r4,r2,r3
    2d1c:	18c00044 	addi	r3,r3,1
    2d20:	21c00005 	stb	r7,0(r4)
    2d24:	003ff906 	br	2d0c <_gp+0xffff7700>
    2d28:	f800283a 	ret

00002d2c <memset>:
    2d2c:	2005883a 	mov	r2,r4
    2d30:	2007883a 	mov	r3,r4
    2d34:	218d883a 	add	r6,r4,r6
    2d38:	19800326 	beq	r3,r6,2d48 <memset+0x1c>
    2d3c:	19400005 	stb	r5,0(r3)
    2d40:	18c00044 	addi	r3,r3,1
    2d44:	003ffc06 	br	2d38 <_gp+0xffff772c>
    2d48:	f800283a 	ret

00002d4c <alt_getchar>:
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
    2d4c:	00800034 	movhi	r2,0
    2d50:	108d6d04 	addi	r2,r2,13748
    2d54:	11c00217 	ldw	r7,8(r2)
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
    2d58:	defffe04 	addi	sp,sp,-8
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
    2d5c:	01000034 	movhi	r4,0
    2d60:	210d8404 	addi	r4,r4,13840
    2d64:	d80b883a 	mov	r5,sp
    2d68:	01800044 	movi	r6,1
 * Uses the ALT_DRIVER_READ() macro to call directly to driver if available.
 * Otherwise, uses newlib provided getchar() routine.
 */
int 
alt_getchar(void)
{
    2d6c:	dfc00115 	stw	ra,4(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
    2d70:	00031900 	call	3190 <altera_avalon_uart_read>
    2d74:	0080020e 	bge	zero,r2,2d80 <alt_getchar+0x34>
        return -1;
    }
    return c;
    2d78:	d8800007 	ldb	r2,0(sp)
    2d7c:	00000106 	br	2d84 <alt_getchar+0x38>
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_READ_EXTERNS(ALT_STDIN_DEV);
    char c;

    if (ALT_DRIVER_READ(ALT_STDIN_DEV, &c, 1, alt_fd_list[STDIN_FILENO].fd_flags) <= 0) {
        return -1;
    2d80:	00bfffc4 	movi	r2,-1
    return c;
#else
    return getchar();
#endif
#endif
}
    2d84:	dfc00117 	ldw	ra,4(sp)
    2d88:	dec00204 	addi	sp,sp,8
    2d8c:	f800283a 	ret

00002d90 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
    2d90:	0002e2c1 	jmpi	2e2c <alt_iic_isr_register>

00002d94 <alt_ic_irq_enable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    2d94:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2d98:	00bfff84 	movi	r2,-2
    2d9c:	3084703a 	and	r2,r6,r2
    2da0:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
    2da4:	00800034 	movhi	r2,0
    2da8:	108da904 	addi	r2,r2,13988
    2dac:	01000044 	movi	r4,1
    2db0:	10c00017 	ldw	r3,0(r2)
    2db4:	214a983a 	sll	r5,r4,r5
    2db8:	28cab03a 	or	r5,r5,r3
    2dbc:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    2dc0:	10800017 	ldw	r2,0(r2)
    2dc4:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2dc8:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
    2dcc:	0005883a 	mov	r2,zero
    2dd0:	f800283a 	ret

00002dd4 <alt_ic_irq_disable>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    2dd4:	000d303a 	rdctl	r6,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2dd8:	00bfff84 	movi	r2,-2
    2ddc:	3084703a 	and	r2,r6,r2
    2de0:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active &= ~(1 << id);
    2de4:	00800034 	movhi	r2,0
    2de8:	108da904 	addi	r2,r2,13988
    2dec:	013fff84 	movi	r4,-2
    2df0:	10c00017 	ldw	r3,0(r2)
    2df4:	214a183a 	rol	r5,r4,r5
    2df8:	28ca703a 	and	r5,r5,r3
    2dfc:	11400015 	stw	r5,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
    2e00:	10800017 	ldw	r2,0(r2)
    2e04:	100170fa 	wrctl	ienable,r2
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2e08:	3001703a 	wrctl	status,r6
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
    2e0c:	0005883a 	mov	r2,zero
    2e10:	f800283a 	ret

00002e14 <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
    2e14:	000530fa 	rdctl	r2,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
    2e18:	00c00044 	movi	r3,1
    2e1c:	194a983a 	sll	r5,r3,r5
    2e20:	1144703a 	and	r2,r2,r5
}
    2e24:	1004c03a 	cmpne	r2,r2,zero
    2e28:	f800283a 	ret

00002e2c <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
    2e2c:	00c007c4 	movi	r3,31
    2e30:	19401616 	blt	r3,r5,2e8c <alt_iic_isr_register+0x60>
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    2e34:	defffe04 	addi	sp,sp,-8
    2e38:	dfc00115 	stw	ra,4(sp)
    2e3c:	dc000015 	stw	r16,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
    2e40:	0021303a 	rdctl	r16,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
    2e44:	00ffff84 	movi	r3,-2
    2e48:	80c6703a 	and	r3,r16,r3
    2e4c:	1801703a 	wrctl	status,r3
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
    2e50:	280490fa 	slli	r2,r5,3
    2e54:	00c00034 	movhi	r3,0
    2e58:	18ceb204 	addi	r3,r3,15048
    2e5c:	1891883a 	add	r8,r3,r2
    2e60:	41800015 	stw	r6,0(r8)
    alt_irq[id].context = isr_context;
    2e64:	41c00115 	stw	r7,4(r8)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
    2e68:	30000226 	beq	r6,zero,2e74 <alt_iic_isr_register+0x48>
    2e6c:	0002d940 	call	2d94 <alt_ic_irq_enable>
    2e70:	00000106 	br	2e78 <alt_iic_isr_register+0x4c>
    2e74:	0002dd40 	call	2dd4 <alt_ic_irq_disable>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
    2e78:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
    2e7c:	dfc00117 	ldw	ra,4(sp)
    2e80:	dc000017 	ldw	r16,0(sp)
    2e84:	dec00204 	addi	sp,sp,8
    2e88:	f800283a 	ret
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
  int rc = -EINVAL;  
    2e8c:	00bffa84 	movi	r2,-22
    2e90:	f800283a 	ret

00002e94 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    2e94:	deffff04 	addi	sp,sp,-4
    2e98:	01000034 	movhi	r4,0
    2e9c:	01400034 	movhi	r5,0
    2ea0:	dfc00015 	stw	ra,0(sp)
    2ea4:	210d6d04 	addi	r4,r4,13748
    2ea8:	294d8b04 	addi	r5,r5,13868

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    2eac:	2140061e 	bne	r4,r5,2ec8 <alt_load+0x34>
    2eb0:	01000034 	movhi	r4,0
    2eb4:	01400034 	movhi	r5,0
    2eb8:	21080804 	addi	r4,r4,8224
    2ebc:	29480804 	addi	r5,r5,8224
    2ec0:	2140141e 	bne	r4,r5,2f14 <alt_load+0x80>
    2ec4:	00000d06 	br	2efc <alt_load+0x68>
    2ec8:	00c00034 	movhi	r3,0
    2ecc:	18cd8b04 	addi	r3,r3,13868
    2ed0:	00bfff04 	movi	r2,-4
    2ed4:	1907c83a 	sub	r3,r3,r4
    2ed8:	1886703a 	and	r3,r3,r2
    2edc:	0005883a 	mov	r2,zero
  {
    while( to != end )
    2ee0:	10fff326 	beq	r2,r3,2eb0 <_gp+0xffff78a4>
    2ee4:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
    2ee8:	39c00017 	ldw	r7,0(r7)
    2eec:	110d883a 	add	r6,r2,r4
    2ef0:	10800104 	addi	r2,r2,4
    2ef4:	31c00015 	stw	r7,0(r6)
    2ef8:	003ff906 	br	2ee0 <_gp+0xffff78d4>
    2efc:	01000034 	movhi	r4,0
    2f00:	01400034 	movhi	r5,0
    2f04:	210cce04 	addi	r4,r4,13112
    2f08:	294cce04 	addi	r5,r5,13112

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    2f0c:	2140121e 	bne	r4,r5,2f58 <alt_load+0xc4>
    2f10:	00000d06 	br	2f48 <alt_load+0xb4>
    2f14:	00c00034 	movhi	r3,0
    2f18:	18c86104 	addi	r3,r3,8580
    2f1c:	00bfff04 	movi	r2,-4
    2f20:	1907c83a 	sub	r3,r3,r4
    2f24:	1886703a 	and	r3,r3,r2
    2f28:	0005883a 	mov	r2,zero
  {
    while( to != end )
    2f2c:	10fff326 	beq	r2,r3,2efc <_gp+0xffff78f0>
    2f30:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
    2f34:	39c00017 	ldw	r7,0(r7)
    2f38:	110d883a 	add	r6,r2,r4
    2f3c:	10800104 	addi	r2,r2,4
    2f40:	31c00015 	stw	r7,0(r6)
    2f44:	003ff906 	br	2f2c <_gp+0xffff7920>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    2f48:	00032ac0 	call	32ac <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    2f4c:	dfc00017 	ldw	ra,0(sp)
    2f50:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    2f54:	00032b81 	jmpi	32b8 <alt_icache_flush_all>
    2f58:	00c00034 	movhi	r3,0
    2f5c:	18cd6d04 	addi	r3,r3,13748
    2f60:	00bfff04 	movi	r2,-4
    2f64:	1907c83a 	sub	r3,r3,r4
    2f68:	1886703a 	and	r3,r3,r2

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    2f6c:	0005883a 	mov	r2,zero
  {
    while( to != end )
    2f70:	10fff526 	beq	r2,r3,2f48 <_gp+0xffff793c>
    2f74:	114f883a 	add	r7,r2,r5
    {
      *to++ = *from++;
    2f78:	39c00017 	ldw	r7,0(r7)
    2f7c:	110d883a 	add	r6,r2,r4
    2f80:	10800104 	addi	r2,r2,4
    2f84:	31c00015 	stw	r7,0(r6)
    2f88:	003ff906 	br	2f70 <_gp+0xffff7964>

00002f8c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    2f8c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    2f90:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    2f94:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    2f98:	000316c0 	call	316c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    2f9c:	000318c0 	call	318c <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    2fa0:	d1202917 	ldw	r4,-32604(gp)
    2fa4:	d1602817 	ldw	r5,-32608(gp)
    2fa8:	d1a02717 	ldw	r6,-32612(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    2fac:	dfc00017 	ldw	ra,0(sp)
    2fb0:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    2fb4:	00029801 	jmpi	2980 <main>

00002fb8 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
    2fb8:	defff204 	addi	sp,sp,-56
    2fbc:	dfc00a15 	stw	ra,40(sp)
    2fc0:	df000915 	stw	fp,36(sp)
    2fc4:	ddc00815 	stw	r23,32(sp)
    2fc8:	dd800715 	stw	r22,28(sp)
    2fcc:	dd400615 	stw	r21,24(sp)
    2fd0:	dd000515 	stw	r20,20(sp)
    2fd4:	dcc00415 	stw	r19,16(sp)
    2fd8:	dc800315 	stw	r18,12(sp)
    2fdc:	dc400215 	stw	r17,8(sp)
    2fe0:	dc000115 	stw	r16,4(sp)
    2fe4:	d9400b15 	stw	r5,44(sp)
    2fe8:	d9800c15 	stw	r6,48(sp)
    2fec:	d9c00d15 	stw	r7,52(sp)
    w = fmt;
    while ((c = *w++) != 0)
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
    2ff0:	04000944 	movi	r16,37
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
    2ff4:	2005883a 	mov	r2,r4
	va_list args;
	va_start(args, fmt);
    2ff8:	dd400b04 	addi	r21,sp,44
                if (c == '%')
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
    2ffc:	048018c4 	movi	r18,99
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
                }
                else if (c == 'x')
    3000:	04c01e04 	movi	r19,120
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
    3004:	05001cc4 	movi	r20,115
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
    3008:	11000007 	ldb	r4,0(r2)
    300c:	20003926 	beq	r4,zero,30f4 <alt_printf+0x13c>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
    3010:	24000226 	beq	r4,r16,301c <alt_printf+0x64>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
    3014:	14400044 	addi	r17,r2,1
    3018:	00001106 	br	3060 <alt_printf+0xa8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
    301c:	14400084 	addi	r17,r2,2
    3020:	10800047 	ldb	r2,1(r2)
    3024:	10003326 	beq	r2,zero,30f4 <alt_printf+0x13c>
            {
                if (c == '%')
    3028:	1400021e 	bne	r2,r16,3034 <alt_printf+0x7c>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
    302c:	8009883a 	mov	r4,r16
    3030:	00000b06 	br	3060 <alt_printf+0xa8>
                } 
                else if (c == 'c')
    3034:	1480051e 	bne	r2,r18,304c <alt_printf+0x94>
                {
                    int v = va_arg(args, int);
                    alt_putchar(v);
    3038:	a9000017 	ldw	r4,0(r21)
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
    303c:	ad800104 	addi	r22,r21,4
    3040:	b02b883a 	mov	r21,r22
                    alt_putchar(v);
    3044:	00031240 	call	3124 <alt_putchar>
    3048:	00002806 	br	30ec <alt_printf+0x134>
                }
                else if (c == 'x')
    304c:	14c01f1e 	bne	r2,r19,30cc <alt_printf+0x114>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
    3050:	adc00017 	ldw	r23,0(r21)
    3054:	ad400104 	addi	r21,r21,4
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
    3058:	b800031e 	bne	r23,zero,3068 <alt_printf+0xb0>
                    {
                        alt_putchar('0');
    305c:	01000c04 	movi	r4,48
    3060:	00031240 	call	3124 <alt_putchar>
                        continue;
    3064:	00002106 	br	30ec <alt_printf+0x134>
    3068:	05800704 	movi	r22,28
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
    306c:	00c003c4 	movi	r3,15
    3070:	1d84983a 	sll	r2,r3,r22
    3074:	15c4703a 	and	r2,r2,r23
    3078:	1000021e 	bne	r2,zero,3084 <alt_printf+0xcc>
                        digit_shift -= 4;
    307c:	b5bfff04 	addi	r22,r22,-4
    3080:	003ffb06 	br	3070 <_gp+0xffff7a64>

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
    3084:	070003c4 	movi	fp,15
                        if (digit <= 9)
    3088:	00c00244 	movi	r3,9
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
    308c:	b0001716 	blt	r22,zero,30ec <alt_printf+0x134>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
    3090:	e584983a 	sll	r2,fp,r22
    3094:	15c4703a 	and	r2,r2,r23
    3098:	1584d83a 	srl	r2,r2,r22
                        if (digit <= 9)
    309c:	18800236 	bltu	r3,r2,30a8 <alt_printf+0xf0>
                            c = '0' + digit;
    30a0:	11000c04 	addi	r4,r2,48
    30a4:	00000106 	br	30ac <alt_printf+0xf4>
                        else
                            c = 'a' + digit - 10;
    30a8:	110015c4 	addi	r4,r2,87
                        alt_putchar(c);
    30ac:	21003fcc 	andi	r4,r4,255
    30b0:	2100201c 	xori	r4,r4,128
    30b4:	213fe004 	addi	r4,r4,-128
    30b8:	d8c00015 	stw	r3,0(sp)
    30bc:	00031240 	call	3124 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
    30c0:	b5bfff04 	addi	r22,r22,-4
    30c4:	d8c00017 	ldw	r3,0(sp)
    30c8:	003ff006 	br	308c <_gp+0xffff7a80>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
    30cc:	1500071e 	bne	r2,r20,30ec <alt_printf+0x134>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
    30d0:	ad800017 	ldw	r22,0(r21)
    30d4:	ad400104 	addi	r21,r21,4

                    while(*s)
    30d8:	b1000007 	ldb	r4,0(r22)
    30dc:	20000326 	beq	r4,zero,30ec <alt_printf+0x134>
                      alt_putchar(*s++);
    30e0:	b5800044 	addi	r22,r22,1
    30e4:	00031240 	call	3124 <alt_putchar>
    30e8:	003ffb06 	br	30d8 <_gp+0xffff7acc>
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
                } 
                else if (c == 'c')
                {
                    int v = va_arg(args, int);
    30ec:	8805883a 	mov	r2,r17
    30f0:	003fc506 	br	3008 <_gp+0xffff79fc>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
    30f4:	dfc00a17 	ldw	ra,40(sp)
    30f8:	df000917 	ldw	fp,36(sp)
    30fc:	ddc00817 	ldw	r23,32(sp)
    3100:	dd800717 	ldw	r22,28(sp)
    3104:	dd400617 	ldw	r21,24(sp)
    3108:	dd000517 	ldw	r20,20(sp)
    310c:	dcc00417 	ldw	r19,16(sp)
    3110:	dc800317 	ldw	r18,12(sp)
    3114:	dc400217 	ldw	r17,8(sp)
    3118:	dc000117 	ldw	r16,4(sp)
    311c:	dec00e04 	addi	sp,sp,56
    3120:	f800283a 	ret

00003124 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
    3124:	defffd04 	addi	sp,sp,-12
    3128:	dc000115 	stw	r16,4(sp)
	char        c1 = (char)(c & 0xff);
    return write(STDOUT_FILENO,&c1,1);
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);
    312c:	d9000005 	stb	r4,0(sp)
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
    3130:	2021883a 	mov	r16,r4
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
    3134:	01000034 	movhi	r4,0
    3138:	210d8404 	addi	r4,r4,13840
    313c:	d80b883a 	mov	r5,sp
    3140:	01800044 	movi	r6,1
    3144:	000f883a 	mov	r7,zero
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
    3148:	dfc00215 	stw	ra,8(sp)
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    char        c1 = (char)(c & 0xff);

    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
    314c:	000321c0 	call	321c <altera_avalon_uart_write>
    3150:	00ffffc4 	movi	r3,-1
    3154:	10c00126 	beq	r2,r3,315c <alt_putchar+0x38>
        return -1;
    }
    return c;
    3158:	8005883a 	mov	r2,r16
#else
    return putchar(c);
#endif
#endif
}
    315c:	dfc00217 	ldw	ra,8(sp)
    3160:	dc000117 	ldw	r16,4(sp)
    3164:	dec00304 	addi	sp,sp,12
    3168:	f800283a 	ret

0000316c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    316c:	deffff04 	addi	sp,sp,-4
    3170:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
    3174:	00033300 	call	3330 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    3178:	00800044 	movi	r2,1
    317c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    3180:	dfc00017 	ldw	ra,0(sp)
    3184:	dec00104 	addi	sp,sp,4
    3188:	f800283a 	ret

0000318c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
    318c:	f800283a 	ret

00003190 <altera_avalon_uart_read>:
  int flags)
{
  int block;
  unsigned int status;

  block = !(flags & O_NONBLOCK);
    3190:	39d0000c 	andi	r7,r7,16384

  do
  {
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
    3194:	20c00017 	ldw	r3,0(r4)
    3198:	18c00204 	addi	r3,r3,8
    319c:	18800037 	ldwio	r2,0(r3)

    /* clear any error flags */

    IOWR_ALTERA_AVALON_UART_STATUS(sp->base, 0);
    31a0:	18000035 	stwio	zero,0(r3)

    if (status & ALTERA_AVALON_UART_CONTROL_RRDY_MSK)
    31a4:	10c0200c 	andi	r3,r2,128
    31a8:	1800021e 	bne	r3,zero,31b4 <altera_avalon_uart_read+0x24>
      {
        return 1;
      }
    }
  }
  while (block);
    31ac:	383ff926 	beq	r7,zero,3194 <_gp+0xffff7b88>
    31b0:	00000706 	br	31d0 <altera_avalon_uart_read+0x40>

    IOWR_ALTERA_AVALON_UART_STATUS(sp->base, 0);

    if (status & ALTERA_AVALON_UART_CONTROL_RRDY_MSK)
    {
      ptr[0] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
    31b4:	20c00017 	ldw	r3,0(r4)
    31b8:	18c00037 	ldwio	r3,0(r3)
    31bc:	28c00005 	stb	r3,0(r5)

      if (!(status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
    31c0:	108000cc 	andi	r2,r2,3
    31c4:	103ff91e 	bne	r2,zero,31ac <_gp+0xffff7ba0>
      ALTERA_AVALON_UART_STATUS_FE_MSK)))
      {
        return 1;
    31c8:	00800044 	movi	r2,1
    31cc:	f800283a 	ret

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
    31d0:	00800034 	movhi	r2,0
    31d4:	108d8a04 	addi	r2,r2,13864
    31d8:	10800017 	ldw	r2,0(r2)
    31dc:	10000926 	beq	r2,zero,3204 <altera_avalon_uart_read+0x74>
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
    31e0:	deffff04 	addi	sp,sp,-4
    31e4:	dfc00015 	stw	ra,0(sp)
    31e8:	103ee83a 	callr	r2
      }
    }
  }
  while (block);

  ALT_ERRNO = EWOULDBLOCK;
    31ec:	00c002c4 	movi	r3,11
    31f0:	10c00015 	stw	r3,0(r2)
 
  return 0;
    31f4:	0005883a 	mov	r2,zero
}
    31f8:	dfc00017 	ldw	ra,0(sp)
    31fc:	dec00104 	addi	sp,sp,4
    3200:	f800283a 	ret
    3204:	00800034 	movhi	r2,0
    3208:	108dae04 	addi	r2,r2,14008
      }
    }
  }
  while (block);

  ALT_ERRNO = EWOULDBLOCK;
    320c:	00c002c4 	movi	r3,11
    3210:	10c00015 	stw	r3,0(r2)
 
  return 0;
    3214:	0005883a 	mov	r2,zero
}
    3218:	f800283a 	ret

0000321c <altera_avalon_uart_write>:
 */

int 
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
    321c:	defffd04 	addi	sp,sp,-12
    3220:	dc400115 	stw	r17,4(sp)
    3224:	dc000015 	stw	r16,0(sp)
    3228:	dfc00215 	stw	ra,8(sp)
    322c:	3023883a 	mov	r17,r6
  int block;
  unsigned int status;
  int count;

  block = !(flags & O_NONBLOCK);
    3230:	39d0000c 	andi	r7,r7,16384
  count = len;
    3234:	3021883a 	mov	r16,r6

  do
  {
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
    3238:	20800017 	ldw	r2,0(r4)
    323c:	10c00237 	ldwio	r3,8(r2)
   
    if (status & ALTERA_AVALON_UART_STATUS_TRDY_MSK)
    3240:	18c0100c 	andi	r3,r3,64
    3244:	18000526 	beq	r3,zero,325c <altera_avalon_uart_write+0x40>
    {
      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, *ptr++);
    3248:	28c00044 	addi	r3,r5,1
    324c:	29400007 	ldb	r5,0(r5)
    3250:	11400135 	stwio	r5,4(r2)
      count--;
    3254:	843fffc4 	addi	r16,r16,-1
  {
    status = IORD_ALTERA_AVALON_UART_STATUS(sp->base);
   
    if (status & ALTERA_AVALON_UART_STATUS_TRDY_MSK)
    {
      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, *ptr++);
    3258:	180b883a 	mov	r5,r3
      count--;
    }
  }
  while (block && count);
    325c:	3800021e 	bne	r7,zero,3268 <altera_avalon_uart_write+0x4c>
    3260:	803ff51e 	bne	r16,zero,3238 <_gp+0xffff7c2c>
    3264:	00000b06 	br	3294 <altera_avalon_uart_write+0x78>

  if (count)
    3268:	80000a26 	beq	r16,zero,3294 <altera_avalon_uart_write+0x78>
    326c:	00800034 	movhi	r2,0
    3270:	108d8a04 	addi	r2,r2,13864
    3274:	10800017 	ldw	r2,0(r2)
    3278:	10000226 	beq	r2,zero,3284 <altera_avalon_uart_write+0x68>
    327c:	103ee83a 	callr	r2
    3280:	00000206 	br	328c <altera_avalon_uart_write+0x70>
    3284:	00800034 	movhi	r2,0
    3288:	108dae04 	addi	r2,r2,14008
  {
    ALT_ERRNO = EWOULDBLOCK;
    328c:	00c002c4 	movi	r3,11
    3290:	10c00015 	stw	r3,0(r2)
  }

  return (len - count);
}
    3294:	8c05c83a 	sub	r2,r17,r16
    3298:	dfc00217 	ldw	ra,8(sp)
    329c:	dc400117 	ldw	r17,4(sp)
    32a0:	dc000017 	ldw	r16,0(sp)
    32a4:	dec00304 	addi	sp,sp,12
    32a8:	f800283a 	ret

000032ac <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
    32ac:	f800283a 	ret

000032b0 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
    32b0:	3005883a 	mov	r2,r6
    32b4:	f800283a 	ret

000032b8 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
    32b8:	f800283a 	ret

000032bc <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
    32bc:	213ffe84 	addi	r4,r4,-6
    32c0:	008003c4 	movi	r2,15
    32c4:	11001636 	bltu	r2,r4,3320 <alt_exception_cause_generated_bad_addr+0x64>
    32c8:	200890ba 	slli	r4,r4,2
    32cc:	00800034 	movhi	r2,0
    32d0:	108cb804 	addi	r2,r2,13024
    32d4:	2089883a 	add	r4,r4,r2
    32d8:	20800017 	ldw	r2,0(r4)
    32dc:	1000683a 	jmp	r2
    32e0:	00003328 	cmpgeui	zero,zero,204
    32e4:	00003328 	cmpgeui	zero,zero,204
    32e8:	00003320 	cmpeqi	zero,zero,204
    32ec:	00003320 	cmpeqi	zero,zero,204
    32f0:	00003320 	cmpeqi	zero,zero,204
    32f4:	00003328 	cmpgeui	zero,zero,204
    32f8:	00003320 	cmpeqi	zero,zero,204
    32fc:	00003320 	cmpeqi	zero,zero,204
    3300:	00003328 	cmpgeui	zero,zero,204
    3304:	00003328 	cmpgeui	zero,zero,204
    3308:	00003320 	cmpeqi	zero,zero,204
    330c:	00003328 	cmpgeui	zero,zero,204
    3310:	00003320 	cmpeqi	zero,zero,204
    3314:	00003320 	cmpeqi	zero,zero,204
    3318:	00003320 	cmpeqi	zero,zero,204
    331c:	00003328 	cmpgeui	zero,zero,204
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
    3320:	0005883a 	mov	r2,zero
    3324:	f800283a 	ret
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
    3328:	00800044 	movi	r2,1
    return 0;

  default:
    return 0;
  }
}
    332c:	f800283a 	ret

00003330 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    3330:	000170fa 	wrctl	ienable,zero
    3334:	f800283a 	ret
